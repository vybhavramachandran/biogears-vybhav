// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Circuit.hxx"

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        // enumCircuitType
        // 

        enumCircuitType::
        enumCircuitType ()
        : ::xml_schema::string ()
        {
        }

        enumCircuitType::
        enumCircuitType (value v)
        : ::xml_schema::string (_xsd_enumCircuitType_literals_[v])
        {
        }

        enumCircuitType::
        enumCircuitType (const char* v)
        : ::xml_schema::string (v)
        {
        }

        enumCircuitType::
        enumCircuitType (const ::std::string& v)
        : ::xml_schema::string (v)
        {
        }

        enumCircuitType::
        enumCircuitType (const ::xml_schema::string& v)
        : ::xml_schema::string (v)
        {
        }

        enumCircuitType::
        enumCircuitType (const enumCircuitType& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
        : ::xml_schema::string (v, f, c)
        {
        }

        enumCircuitType& enumCircuitType::
        operator= (value v)
        {
          static_cast< ::xml_schema::string& > (*this) = 
          ::xml_schema::string (_xsd_enumCircuitType_literals_[v]);

          return *this;
        }


        // enumResistancePathType
        // 

        enumResistancePathType::
        enumResistancePathType ()
        : ::xml_schema::string ()
        {
        }

        enumResistancePathType::
        enumResistancePathType (value v)
        : ::xml_schema::string (_xsd_enumResistancePathType_literals_[v])
        {
        }

        enumResistancePathType::
        enumResistancePathType (const char* v)
        : ::xml_schema::string (v)
        {
        }

        enumResistancePathType::
        enumResistancePathType (const ::std::string& v)
        : ::xml_schema::string (v)
        {
        }

        enumResistancePathType::
        enumResistancePathType (const ::xml_schema::string& v)
        : ::xml_schema::string (v)
        {
        }

        enumResistancePathType::
        enumResistancePathType (const enumResistancePathType& v,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
        : ::xml_schema::string (v, f, c)
        {
        }

        enumResistancePathType& enumResistancePathType::
        operator= (value v)
        {
          static_cast< ::xml_schema::string& > (*this) = 
          ::xml_schema::string (_xsd_enumResistancePathType_literals_[v]);

          return *this;
        }


        // CircuitData
        // 

        const CircuitData::Name_type& CircuitData::
        Name () const
        {
          return this->Name_.get ();
        }

        CircuitData::Name_type& CircuitData::
        Name ()
        {
          return this->Name_.get ();
        }

        void CircuitData::
        Name (const Name_type& x)
        {
          this->Name_.set (x);
        }

        void CircuitData::
        Name (::std::unique_ptr< Name_type > x)
        {
          this->Name_.set (std::move (x));
        }

        const CircuitData::ReferenceNode_sequence& CircuitData::
        ReferenceNode () const
        {
          return this->ReferenceNode_;
        }

        CircuitData::ReferenceNode_sequence& CircuitData::
        ReferenceNode ()
        {
          return this->ReferenceNode_;
        }

        void CircuitData::
        ReferenceNode (const ReferenceNode_sequence& s)
        {
          this->ReferenceNode_ = s;
        }


        // CircuitNodeData
        // 

        const CircuitNodeData::Name_type& CircuitNodeData::
        Name () const
        {
          return this->Name_.get ();
        }

        CircuitNodeData::Name_type& CircuitNodeData::
        Name ()
        {
          return this->Name_.get ();
        }

        void CircuitNodeData::
        Name (const Name_type& x)
        {
          this->Name_.set (x);
        }

        void CircuitNodeData::
        Name (::std::unique_ptr< Name_type > x)
        {
          this->Name_.set (std::move (x));
        }


        // CircuitPathData
        // 

        const CircuitPathData::Name_type& CircuitPathData::
        Name () const
        {
          return this->Name_.get ();
        }

        CircuitPathData::Name_type& CircuitPathData::
        Name ()
        {
          return this->Name_.get ();
        }

        void CircuitPathData::
        Name (const Name_type& x)
        {
          this->Name_.set (x);
        }

        void CircuitPathData::
        Name (::std::unique_ptr< Name_type > x)
        {
          this->Name_.set (std::move (x));
        }

        const CircuitPathData::SourceNode_type& CircuitPathData::
        SourceNode () const
        {
          return this->SourceNode_.get ();
        }

        CircuitPathData::SourceNode_type& CircuitPathData::
        SourceNode ()
        {
          return this->SourceNode_.get ();
        }

        void CircuitPathData::
        SourceNode (const SourceNode_type& x)
        {
          this->SourceNode_.set (x);
        }

        void CircuitPathData::
        SourceNode (::std::unique_ptr< SourceNode_type > x)
        {
          this->SourceNode_.set (std::move (x));
        }

        const CircuitPathData::TargetNode_type& CircuitPathData::
        TargetNode () const
        {
          return this->TargetNode_.get ();
        }

        CircuitPathData::TargetNode_type& CircuitPathData::
        TargetNode ()
        {
          return this->TargetNode_.get ();
        }

        void CircuitPathData::
        TargetNode (const TargetNode_type& x)
        {
          this->TargetNode_.set (x);
        }

        void CircuitPathData::
        TargetNode (::std::unique_ptr< TargetNode_type > x)
        {
          this->TargetNode_.set (std::move (x));
        }

        const CircuitPathData::Switch_optional& CircuitPathData::
        Switch () const
        {
          return this->Switch_;
        }

        CircuitPathData::Switch_optional& CircuitPathData::
        Switch ()
        {
          return this->Switch_;
        }

        void CircuitPathData::
        Switch (const Switch_type& x)
        {
          this->Switch_.set (x);
        }

        void CircuitPathData::
        Switch (const Switch_optional& x)
        {
          this->Switch_ = x;
        }

        void CircuitPathData::
        Switch (::std::unique_ptr< Switch_type > x)
        {
          this->Switch_.set (std::move (x));
        }

        const CircuitPathData::NextSwitch_optional& CircuitPathData::
        NextSwitch () const
        {
          return this->NextSwitch_;
        }

        CircuitPathData::NextSwitch_optional& CircuitPathData::
        NextSwitch ()
        {
          return this->NextSwitch_;
        }

        void CircuitPathData::
        NextSwitch (const NextSwitch_type& x)
        {
          this->NextSwitch_.set (x);
        }

        void CircuitPathData::
        NextSwitch (const NextSwitch_optional& x)
        {
          this->NextSwitch_ = x;
        }

        void CircuitPathData::
        NextSwitch (::std::unique_ptr< NextSwitch_type > x)
        {
          this->NextSwitch_.set (std::move (x));
        }

        const CircuitPathData::Valve_optional& CircuitPathData::
        Valve () const
        {
          return this->Valve_;
        }

        CircuitPathData::Valve_optional& CircuitPathData::
        Valve ()
        {
          return this->Valve_;
        }

        void CircuitPathData::
        Valve (const Valve_type& x)
        {
          this->Valve_.set (x);
        }

        void CircuitPathData::
        Valve (const Valve_optional& x)
        {
          this->Valve_ = x;
        }

        void CircuitPathData::
        Valve (::std::unique_ptr< Valve_type > x)
        {
          this->Valve_.set (std::move (x));
        }

        const CircuitPathData::NextValve_optional& CircuitPathData::
        NextValve () const
        {
          return this->NextValve_;
        }

        CircuitPathData::NextValve_optional& CircuitPathData::
        NextValve ()
        {
          return this->NextValve_;
        }

        void CircuitPathData::
        NextValve (const NextValve_type& x)
        {
          this->NextValve_.set (x);
        }

        void CircuitPathData::
        NextValve (const NextValve_optional& x)
        {
          this->NextValve_ = x;
        }

        void CircuitPathData::
        NextValve (::std::unique_ptr< NextValve_type > x)
        {
          this->NextValve_.set (std::move (x));
        }

        const CircuitPathData::PolarizedState_optional& CircuitPathData::
        PolarizedState () const
        {
          return this->PolarizedState_;
        }

        CircuitPathData::PolarizedState_optional& CircuitPathData::
        PolarizedState ()
        {
          return this->PolarizedState_;
        }

        void CircuitPathData::
        PolarizedState (const PolarizedState_type& x)
        {
          this->PolarizedState_.set (x);
        }

        void CircuitPathData::
        PolarizedState (const PolarizedState_optional& x)
        {
          this->PolarizedState_ = x;
        }

        void CircuitPathData::
        PolarizedState (::std::unique_ptr< PolarizedState_type > x)
        {
          this->PolarizedState_.set (std::move (x));
        }

        const CircuitPathData::NextPolarizedState_optional& CircuitPathData::
        NextPolarizedState () const
        {
          return this->NextPolarizedState_;
        }

        CircuitPathData::NextPolarizedState_optional& CircuitPathData::
        NextPolarizedState ()
        {
          return this->NextPolarizedState_;
        }

        void CircuitPathData::
        NextPolarizedState (const NextPolarizedState_type& x)
        {
          this->NextPolarizedState_.set (x);
        }

        void CircuitPathData::
        NextPolarizedState (const NextPolarizedState_optional& x)
        {
          this->NextPolarizedState_ = x;
        }

        void CircuitPathData::
        NextPolarizedState (::std::unique_ptr< NextPolarizedState_type > x)
        {
          this->NextPolarizedState_.set (std::move (x));
        }


        // ElectricalCircuitData
        // 

        const ElectricalCircuitData::Node_sequence& ElectricalCircuitData::
        Node () const
        {
          return this->Node_;
        }

        ElectricalCircuitData::Node_sequence& ElectricalCircuitData::
        Node ()
        {
          return this->Node_;
        }

        void ElectricalCircuitData::
        Node (const Node_sequence& s)
        {
          this->Node_ = s;
        }

        const ElectricalCircuitData::Path_sequence& ElectricalCircuitData::
        Path () const
        {
          return this->Path_;
        }

        ElectricalCircuitData::Path_sequence& ElectricalCircuitData::
        Path ()
        {
          return this->Path_;
        }

        void ElectricalCircuitData::
        Path (const Path_sequence& s)
        {
          this->Path_ = s;
        }


        // ElectricalCircuitNodeData
        // 

        const ElectricalCircuitNodeData::Voltage_optional& ElectricalCircuitNodeData::
        Voltage () const
        {
          return this->Voltage_;
        }

        ElectricalCircuitNodeData::Voltage_optional& ElectricalCircuitNodeData::
        Voltage ()
        {
          return this->Voltage_;
        }

        void ElectricalCircuitNodeData::
        Voltage (const Voltage_type& x)
        {
          this->Voltage_.set (x);
        }

        void ElectricalCircuitNodeData::
        Voltage (const Voltage_optional& x)
        {
          this->Voltage_ = x;
        }

        void ElectricalCircuitNodeData::
        Voltage (::std::unique_ptr< Voltage_type > x)
        {
          this->Voltage_.set (std::move (x));
        }

        const ElectricalCircuitNodeData::NextVoltage_optional& ElectricalCircuitNodeData::
        NextVoltage () const
        {
          return this->NextVoltage_;
        }

        ElectricalCircuitNodeData::NextVoltage_optional& ElectricalCircuitNodeData::
        NextVoltage ()
        {
          return this->NextVoltage_;
        }

        void ElectricalCircuitNodeData::
        NextVoltage (const NextVoltage_type& x)
        {
          this->NextVoltage_.set (x);
        }

        void ElectricalCircuitNodeData::
        NextVoltage (const NextVoltage_optional& x)
        {
          this->NextVoltage_ = x;
        }

        void ElectricalCircuitNodeData::
        NextVoltage (::std::unique_ptr< NextVoltage_type > x)
        {
          this->NextVoltage_.set (std::move (x));
        }

        const ElectricalCircuitNodeData::Charge_optional& ElectricalCircuitNodeData::
        Charge () const
        {
          return this->Charge_;
        }

        ElectricalCircuitNodeData::Charge_optional& ElectricalCircuitNodeData::
        Charge ()
        {
          return this->Charge_;
        }

        void ElectricalCircuitNodeData::
        Charge (const Charge_type& x)
        {
          this->Charge_.set (x);
        }

        void ElectricalCircuitNodeData::
        Charge (const Charge_optional& x)
        {
          this->Charge_ = x;
        }

        void ElectricalCircuitNodeData::
        Charge (::std::unique_ptr< Charge_type > x)
        {
          this->Charge_.set (std::move (x));
        }

        const ElectricalCircuitNodeData::NextCharge_optional& ElectricalCircuitNodeData::
        NextCharge () const
        {
          return this->NextCharge_;
        }

        ElectricalCircuitNodeData::NextCharge_optional& ElectricalCircuitNodeData::
        NextCharge ()
        {
          return this->NextCharge_;
        }

        void ElectricalCircuitNodeData::
        NextCharge (const NextCharge_type& x)
        {
          this->NextCharge_.set (x);
        }

        void ElectricalCircuitNodeData::
        NextCharge (const NextCharge_optional& x)
        {
          this->NextCharge_ = x;
        }

        void ElectricalCircuitNodeData::
        NextCharge (::std::unique_ptr< NextCharge_type > x)
        {
          this->NextCharge_.set (std::move (x));
        }

        const ElectricalCircuitNodeData::ChargeBaseline_optional& ElectricalCircuitNodeData::
        ChargeBaseline () const
        {
          return this->ChargeBaseline_;
        }

        ElectricalCircuitNodeData::ChargeBaseline_optional& ElectricalCircuitNodeData::
        ChargeBaseline ()
        {
          return this->ChargeBaseline_;
        }

        void ElectricalCircuitNodeData::
        ChargeBaseline (const ChargeBaseline_type& x)
        {
          this->ChargeBaseline_.set (x);
        }

        void ElectricalCircuitNodeData::
        ChargeBaseline (const ChargeBaseline_optional& x)
        {
          this->ChargeBaseline_ = x;
        }

        void ElectricalCircuitNodeData::
        ChargeBaseline (::std::unique_ptr< ChargeBaseline_type > x)
        {
          this->ChargeBaseline_.set (std::move (x));
        }


        // ElectricalCircuitPathData
        // 

        const ElectricalCircuitPathData::Resistance_optional& ElectricalCircuitPathData::
        Resistance () const
        {
          return this->Resistance_;
        }

        ElectricalCircuitPathData::Resistance_optional& ElectricalCircuitPathData::
        Resistance ()
        {
          return this->Resistance_;
        }

        void ElectricalCircuitPathData::
        Resistance (const Resistance_type& x)
        {
          this->Resistance_.set (x);
        }

        void ElectricalCircuitPathData::
        Resistance (const Resistance_optional& x)
        {
          this->Resistance_ = x;
        }

        void ElectricalCircuitPathData::
        Resistance (::std::unique_ptr< Resistance_type > x)
        {
          this->Resistance_.set (std::move (x));
        }

        const ElectricalCircuitPathData::NextResistance_optional& ElectricalCircuitPathData::
        NextResistance () const
        {
          return this->NextResistance_;
        }

        ElectricalCircuitPathData::NextResistance_optional& ElectricalCircuitPathData::
        NextResistance ()
        {
          return this->NextResistance_;
        }

        void ElectricalCircuitPathData::
        NextResistance (const NextResistance_type& x)
        {
          this->NextResistance_.set (x);
        }

        void ElectricalCircuitPathData::
        NextResistance (const NextResistance_optional& x)
        {
          this->NextResistance_ = x;
        }

        void ElectricalCircuitPathData::
        NextResistance (::std::unique_ptr< NextResistance_type > x)
        {
          this->NextResistance_.set (std::move (x));
        }

        const ElectricalCircuitPathData::ResistanceBaseline_optional& ElectricalCircuitPathData::
        ResistanceBaseline () const
        {
          return this->ResistanceBaseline_;
        }

        ElectricalCircuitPathData::ResistanceBaseline_optional& ElectricalCircuitPathData::
        ResistanceBaseline ()
        {
          return this->ResistanceBaseline_;
        }

        void ElectricalCircuitPathData::
        ResistanceBaseline (const ResistanceBaseline_type& x)
        {
          this->ResistanceBaseline_.set (x);
        }

        void ElectricalCircuitPathData::
        ResistanceBaseline (const ResistanceBaseline_optional& x)
        {
          this->ResistanceBaseline_ = x;
        }

        void ElectricalCircuitPathData::
        ResistanceBaseline (::std::unique_ptr< ResistanceBaseline_type > x)
        {
          this->ResistanceBaseline_.set (std::move (x));
        }

        const ElectricalCircuitPathData::Capacitance_optional& ElectricalCircuitPathData::
        Capacitance () const
        {
          return this->Capacitance_;
        }

        ElectricalCircuitPathData::Capacitance_optional& ElectricalCircuitPathData::
        Capacitance ()
        {
          return this->Capacitance_;
        }

        void ElectricalCircuitPathData::
        Capacitance (const Capacitance_type& x)
        {
          this->Capacitance_.set (x);
        }

        void ElectricalCircuitPathData::
        Capacitance (const Capacitance_optional& x)
        {
          this->Capacitance_ = x;
        }

        void ElectricalCircuitPathData::
        Capacitance (::std::unique_ptr< Capacitance_type > x)
        {
          this->Capacitance_.set (std::move (x));
        }

        const ElectricalCircuitPathData::NextCapacitance_optional& ElectricalCircuitPathData::
        NextCapacitance () const
        {
          return this->NextCapacitance_;
        }

        ElectricalCircuitPathData::NextCapacitance_optional& ElectricalCircuitPathData::
        NextCapacitance ()
        {
          return this->NextCapacitance_;
        }

        void ElectricalCircuitPathData::
        NextCapacitance (const NextCapacitance_type& x)
        {
          this->NextCapacitance_.set (x);
        }

        void ElectricalCircuitPathData::
        NextCapacitance (const NextCapacitance_optional& x)
        {
          this->NextCapacitance_ = x;
        }

        void ElectricalCircuitPathData::
        NextCapacitance (::std::unique_ptr< NextCapacitance_type > x)
        {
          this->NextCapacitance_.set (std::move (x));
        }

        const ElectricalCircuitPathData::CapacitanceBaseline_optional& ElectricalCircuitPathData::
        CapacitanceBaseline () const
        {
          return this->CapacitanceBaseline_;
        }

        ElectricalCircuitPathData::CapacitanceBaseline_optional& ElectricalCircuitPathData::
        CapacitanceBaseline ()
        {
          return this->CapacitanceBaseline_;
        }

        void ElectricalCircuitPathData::
        CapacitanceBaseline (const CapacitanceBaseline_type& x)
        {
          this->CapacitanceBaseline_.set (x);
        }

        void ElectricalCircuitPathData::
        CapacitanceBaseline (const CapacitanceBaseline_optional& x)
        {
          this->CapacitanceBaseline_ = x;
        }

        void ElectricalCircuitPathData::
        CapacitanceBaseline (::std::unique_ptr< CapacitanceBaseline_type > x)
        {
          this->CapacitanceBaseline_.set (std::move (x));
        }

        const ElectricalCircuitPathData::Inductance_optional& ElectricalCircuitPathData::
        Inductance () const
        {
          return this->Inductance_;
        }

        ElectricalCircuitPathData::Inductance_optional& ElectricalCircuitPathData::
        Inductance ()
        {
          return this->Inductance_;
        }

        void ElectricalCircuitPathData::
        Inductance (const Inductance_type& x)
        {
          this->Inductance_.set (x);
        }

        void ElectricalCircuitPathData::
        Inductance (const Inductance_optional& x)
        {
          this->Inductance_ = x;
        }

        void ElectricalCircuitPathData::
        Inductance (::std::unique_ptr< Inductance_type > x)
        {
          this->Inductance_.set (std::move (x));
        }

        const ElectricalCircuitPathData::NextInductance_optional& ElectricalCircuitPathData::
        NextInductance () const
        {
          return this->NextInductance_;
        }

        ElectricalCircuitPathData::NextInductance_optional& ElectricalCircuitPathData::
        NextInductance ()
        {
          return this->NextInductance_;
        }

        void ElectricalCircuitPathData::
        NextInductance (const NextInductance_type& x)
        {
          this->NextInductance_.set (x);
        }

        void ElectricalCircuitPathData::
        NextInductance (const NextInductance_optional& x)
        {
          this->NextInductance_ = x;
        }

        void ElectricalCircuitPathData::
        NextInductance (::std::unique_ptr< NextInductance_type > x)
        {
          this->NextInductance_.set (std::move (x));
        }

        const ElectricalCircuitPathData::InductanceBaseline_optional& ElectricalCircuitPathData::
        InductanceBaseline () const
        {
          return this->InductanceBaseline_;
        }

        ElectricalCircuitPathData::InductanceBaseline_optional& ElectricalCircuitPathData::
        InductanceBaseline ()
        {
          return this->InductanceBaseline_;
        }

        void ElectricalCircuitPathData::
        InductanceBaseline (const InductanceBaseline_type& x)
        {
          this->InductanceBaseline_.set (x);
        }

        void ElectricalCircuitPathData::
        InductanceBaseline (const InductanceBaseline_optional& x)
        {
          this->InductanceBaseline_ = x;
        }

        void ElectricalCircuitPathData::
        InductanceBaseline (::std::unique_ptr< InductanceBaseline_type > x)
        {
          this->InductanceBaseline_.set (std::move (x));
        }

        const ElectricalCircuitPathData::Current_optional& ElectricalCircuitPathData::
        Current () const
        {
          return this->Current_;
        }

        ElectricalCircuitPathData::Current_optional& ElectricalCircuitPathData::
        Current ()
        {
          return this->Current_;
        }

        void ElectricalCircuitPathData::
        Current (const Current_type& x)
        {
          this->Current_.set (x);
        }

        void ElectricalCircuitPathData::
        Current (const Current_optional& x)
        {
          this->Current_ = x;
        }

        void ElectricalCircuitPathData::
        Current (::std::unique_ptr< Current_type > x)
        {
          this->Current_.set (std::move (x));
        }

        const ElectricalCircuitPathData::NextCurrent_optional& ElectricalCircuitPathData::
        NextCurrent () const
        {
          return this->NextCurrent_;
        }

        ElectricalCircuitPathData::NextCurrent_optional& ElectricalCircuitPathData::
        NextCurrent ()
        {
          return this->NextCurrent_;
        }

        void ElectricalCircuitPathData::
        NextCurrent (const NextCurrent_type& x)
        {
          this->NextCurrent_.set (x);
        }

        void ElectricalCircuitPathData::
        NextCurrent (const NextCurrent_optional& x)
        {
          this->NextCurrent_ = x;
        }

        void ElectricalCircuitPathData::
        NextCurrent (::std::unique_ptr< NextCurrent_type > x)
        {
          this->NextCurrent_.set (std::move (x));
        }

        const ElectricalCircuitPathData::CurrentSource_optional& ElectricalCircuitPathData::
        CurrentSource () const
        {
          return this->CurrentSource_;
        }

        ElectricalCircuitPathData::CurrentSource_optional& ElectricalCircuitPathData::
        CurrentSource ()
        {
          return this->CurrentSource_;
        }

        void ElectricalCircuitPathData::
        CurrentSource (const CurrentSource_type& x)
        {
          this->CurrentSource_.set (x);
        }

        void ElectricalCircuitPathData::
        CurrentSource (const CurrentSource_optional& x)
        {
          this->CurrentSource_ = x;
        }

        void ElectricalCircuitPathData::
        CurrentSource (::std::unique_ptr< CurrentSource_type > x)
        {
          this->CurrentSource_.set (std::move (x));
        }

        const ElectricalCircuitPathData::NextCurrentSource_optional& ElectricalCircuitPathData::
        NextCurrentSource () const
        {
          return this->NextCurrentSource_;
        }

        ElectricalCircuitPathData::NextCurrentSource_optional& ElectricalCircuitPathData::
        NextCurrentSource ()
        {
          return this->NextCurrentSource_;
        }

        void ElectricalCircuitPathData::
        NextCurrentSource (const NextCurrentSource_type& x)
        {
          this->NextCurrentSource_.set (x);
        }

        void ElectricalCircuitPathData::
        NextCurrentSource (const NextCurrentSource_optional& x)
        {
          this->NextCurrentSource_ = x;
        }

        void ElectricalCircuitPathData::
        NextCurrentSource (::std::unique_ptr< NextCurrentSource_type > x)
        {
          this->NextCurrentSource_.set (std::move (x));
        }

        const ElectricalCircuitPathData::CurrentSourceBaseline_optional& ElectricalCircuitPathData::
        CurrentSourceBaseline () const
        {
          return this->CurrentSourceBaseline_;
        }

        ElectricalCircuitPathData::CurrentSourceBaseline_optional& ElectricalCircuitPathData::
        CurrentSourceBaseline ()
        {
          return this->CurrentSourceBaseline_;
        }

        void ElectricalCircuitPathData::
        CurrentSourceBaseline (const CurrentSourceBaseline_type& x)
        {
          this->CurrentSourceBaseline_.set (x);
        }

        void ElectricalCircuitPathData::
        CurrentSourceBaseline (const CurrentSourceBaseline_optional& x)
        {
          this->CurrentSourceBaseline_ = x;
        }

        void ElectricalCircuitPathData::
        CurrentSourceBaseline (::std::unique_ptr< CurrentSourceBaseline_type > x)
        {
          this->CurrentSourceBaseline_.set (std::move (x));
        }

        const ElectricalCircuitPathData::VoltageSource_optional& ElectricalCircuitPathData::
        VoltageSource () const
        {
          return this->VoltageSource_;
        }

        ElectricalCircuitPathData::VoltageSource_optional& ElectricalCircuitPathData::
        VoltageSource ()
        {
          return this->VoltageSource_;
        }

        void ElectricalCircuitPathData::
        VoltageSource (const VoltageSource_type& x)
        {
          this->VoltageSource_.set (x);
        }

        void ElectricalCircuitPathData::
        VoltageSource (const VoltageSource_optional& x)
        {
          this->VoltageSource_ = x;
        }

        void ElectricalCircuitPathData::
        VoltageSource (::std::unique_ptr< VoltageSource_type > x)
        {
          this->VoltageSource_.set (std::move (x));
        }

        const ElectricalCircuitPathData::NextVoltageSource_optional& ElectricalCircuitPathData::
        NextVoltageSource () const
        {
          return this->NextVoltageSource_;
        }

        ElectricalCircuitPathData::NextVoltageSource_optional& ElectricalCircuitPathData::
        NextVoltageSource ()
        {
          return this->NextVoltageSource_;
        }

        void ElectricalCircuitPathData::
        NextVoltageSource (const NextVoltageSource_type& x)
        {
          this->NextVoltageSource_.set (x);
        }

        void ElectricalCircuitPathData::
        NextVoltageSource (const NextVoltageSource_optional& x)
        {
          this->NextVoltageSource_ = x;
        }

        void ElectricalCircuitPathData::
        NextVoltageSource (::std::unique_ptr< NextVoltageSource_type > x)
        {
          this->NextVoltageSource_.set (std::move (x));
        }

        const ElectricalCircuitPathData::VoltageSourceBaseline_optional& ElectricalCircuitPathData::
        VoltageSourceBaseline () const
        {
          return this->VoltageSourceBaseline_;
        }

        ElectricalCircuitPathData::VoltageSourceBaseline_optional& ElectricalCircuitPathData::
        VoltageSourceBaseline ()
        {
          return this->VoltageSourceBaseline_;
        }

        void ElectricalCircuitPathData::
        VoltageSourceBaseline (const VoltageSourceBaseline_type& x)
        {
          this->VoltageSourceBaseline_.set (x);
        }

        void ElectricalCircuitPathData::
        VoltageSourceBaseline (const VoltageSourceBaseline_optional& x)
        {
          this->VoltageSourceBaseline_ = x;
        }

        void ElectricalCircuitPathData::
        VoltageSourceBaseline (::std::unique_ptr< VoltageSourceBaseline_type > x)
        {
          this->VoltageSourceBaseline_.set (std::move (x));
        }

        const ElectricalCircuitPathData::ValveBreakdownVoltage_optional& ElectricalCircuitPathData::
        ValveBreakdownVoltage () const
        {
          return this->ValveBreakdownVoltage_;
        }

        ElectricalCircuitPathData::ValveBreakdownVoltage_optional& ElectricalCircuitPathData::
        ValveBreakdownVoltage ()
        {
          return this->ValveBreakdownVoltage_;
        }

        void ElectricalCircuitPathData::
        ValveBreakdownVoltage (const ValveBreakdownVoltage_type& x)
        {
          this->ValveBreakdownVoltage_.set (x);
        }

        void ElectricalCircuitPathData::
        ValveBreakdownVoltage (const ValveBreakdownVoltage_optional& x)
        {
          this->ValveBreakdownVoltage_ = x;
        }

        void ElectricalCircuitPathData::
        ValveBreakdownVoltage (::std::unique_ptr< ValveBreakdownVoltage_type > x)
        {
          this->ValveBreakdownVoltage_.set (std::move (x));
        }


        // FluidCircuitData
        // 

        const FluidCircuitData::Node_sequence& FluidCircuitData::
        Node () const
        {
          return this->Node_;
        }

        FluidCircuitData::Node_sequence& FluidCircuitData::
        Node ()
        {
          return this->Node_;
        }

        void FluidCircuitData::
        Node (const Node_sequence& s)
        {
          this->Node_ = s;
        }

        const FluidCircuitData::Path_sequence& FluidCircuitData::
        Path () const
        {
          return this->Path_;
        }

        FluidCircuitData::Path_sequence& FluidCircuitData::
        Path ()
        {
          return this->Path_;
        }

        void FluidCircuitData::
        Path (const Path_sequence& s)
        {
          this->Path_ = s;
        }


        // FluidCircuitNodeData
        // 

        const FluidCircuitNodeData::Pressure_optional& FluidCircuitNodeData::
        Pressure () const
        {
          return this->Pressure_;
        }

        FluidCircuitNodeData::Pressure_optional& FluidCircuitNodeData::
        Pressure ()
        {
          return this->Pressure_;
        }

        void FluidCircuitNodeData::
        Pressure (const Pressure_type& x)
        {
          this->Pressure_.set (x);
        }

        void FluidCircuitNodeData::
        Pressure (const Pressure_optional& x)
        {
          this->Pressure_ = x;
        }

        void FluidCircuitNodeData::
        Pressure (::std::unique_ptr< Pressure_type > x)
        {
          this->Pressure_.set (std::move (x));
        }

        const FluidCircuitNodeData::NextPressure_optional& FluidCircuitNodeData::
        NextPressure () const
        {
          return this->NextPressure_;
        }

        FluidCircuitNodeData::NextPressure_optional& FluidCircuitNodeData::
        NextPressure ()
        {
          return this->NextPressure_;
        }

        void FluidCircuitNodeData::
        NextPressure (const NextPressure_type& x)
        {
          this->NextPressure_.set (x);
        }

        void FluidCircuitNodeData::
        NextPressure (const NextPressure_optional& x)
        {
          this->NextPressure_ = x;
        }

        void FluidCircuitNodeData::
        NextPressure (::std::unique_ptr< NextPressure_type > x)
        {
          this->NextPressure_.set (std::move (x));
        }

        const FluidCircuitNodeData::Volume_optional& FluidCircuitNodeData::
        Volume () const
        {
          return this->Volume_;
        }

        FluidCircuitNodeData::Volume_optional& FluidCircuitNodeData::
        Volume ()
        {
          return this->Volume_;
        }

        void FluidCircuitNodeData::
        Volume (const Volume_type& x)
        {
          this->Volume_.set (x);
        }

        void FluidCircuitNodeData::
        Volume (const Volume_optional& x)
        {
          this->Volume_ = x;
        }

        void FluidCircuitNodeData::
        Volume (::std::unique_ptr< Volume_type > x)
        {
          this->Volume_.set (std::move (x));
        }

        const FluidCircuitNodeData::NextVolume_optional& FluidCircuitNodeData::
        NextVolume () const
        {
          return this->NextVolume_;
        }

        FluidCircuitNodeData::NextVolume_optional& FluidCircuitNodeData::
        NextVolume ()
        {
          return this->NextVolume_;
        }

        void FluidCircuitNodeData::
        NextVolume (const NextVolume_type& x)
        {
          this->NextVolume_.set (x);
        }

        void FluidCircuitNodeData::
        NextVolume (const NextVolume_optional& x)
        {
          this->NextVolume_ = x;
        }

        void FluidCircuitNodeData::
        NextVolume (::std::unique_ptr< NextVolume_type > x)
        {
          this->NextVolume_.set (std::move (x));
        }

        const FluidCircuitNodeData::VolumeBaseline_optional& FluidCircuitNodeData::
        VolumeBaseline () const
        {
          return this->VolumeBaseline_;
        }

        FluidCircuitNodeData::VolumeBaseline_optional& FluidCircuitNodeData::
        VolumeBaseline ()
        {
          return this->VolumeBaseline_;
        }

        void FluidCircuitNodeData::
        VolumeBaseline (const VolumeBaseline_type& x)
        {
          this->VolumeBaseline_.set (x);
        }

        void FluidCircuitNodeData::
        VolumeBaseline (const VolumeBaseline_optional& x)
        {
          this->VolumeBaseline_ = x;
        }

        void FluidCircuitNodeData::
        VolumeBaseline (::std::unique_ptr< VolumeBaseline_type > x)
        {
          this->VolumeBaseline_.set (std::move (x));
        }


        // FluidCircuitPathData
        // 

        const FluidCircuitPathData::Resistance_optional& FluidCircuitPathData::
        Resistance () const
        {
          return this->Resistance_;
        }

        FluidCircuitPathData::Resistance_optional& FluidCircuitPathData::
        Resistance ()
        {
          return this->Resistance_;
        }

        void FluidCircuitPathData::
        Resistance (const Resistance_type& x)
        {
          this->Resistance_.set (x);
        }

        void FluidCircuitPathData::
        Resistance (const Resistance_optional& x)
        {
          this->Resistance_ = x;
        }

        void FluidCircuitPathData::
        Resistance (::std::unique_ptr< Resistance_type > x)
        {
          this->Resistance_.set (std::move (x));
        }

        const FluidCircuitPathData::NextResistance_optional& FluidCircuitPathData::
        NextResistance () const
        {
          return this->NextResistance_;
        }

        FluidCircuitPathData::NextResistance_optional& FluidCircuitPathData::
        NextResistance ()
        {
          return this->NextResistance_;
        }

        void FluidCircuitPathData::
        NextResistance (const NextResistance_type& x)
        {
          this->NextResistance_.set (x);
        }

        void FluidCircuitPathData::
        NextResistance (const NextResistance_optional& x)
        {
          this->NextResistance_ = x;
        }

        void FluidCircuitPathData::
        NextResistance (::std::unique_ptr< NextResistance_type > x)
        {
          this->NextResistance_.set (std::move (x));
        }

        const FluidCircuitPathData::ResistanceBaseline_optional& FluidCircuitPathData::
        ResistanceBaseline () const
        {
          return this->ResistanceBaseline_;
        }

        FluidCircuitPathData::ResistanceBaseline_optional& FluidCircuitPathData::
        ResistanceBaseline ()
        {
          return this->ResistanceBaseline_;
        }

        void FluidCircuitPathData::
        ResistanceBaseline (const ResistanceBaseline_type& x)
        {
          this->ResistanceBaseline_.set (x);
        }

        void FluidCircuitPathData::
        ResistanceBaseline (const ResistanceBaseline_optional& x)
        {
          this->ResistanceBaseline_ = x;
        }

        void FluidCircuitPathData::
        ResistanceBaseline (::std::unique_ptr< ResistanceBaseline_type > x)
        {
          this->ResistanceBaseline_.set (std::move (x));
        }

        const FluidCircuitPathData::CardiovascularRegion_optional& FluidCircuitPathData::
        CardiovascularRegion () const
        {
          return this->CardiovascularRegion_;
        }

        FluidCircuitPathData::CardiovascularRegion_optional& FluidCircuitPathData::
        CardiovascularRegion ()
        {
          return this->CardiovascularRegion_;
        }

        void FluidCircuitPathData::
        CardiovascularRegion (const CardiovascularRegion_type& x)
        {
          this->CardiovascularRegion_.set (x);
        }

        void FluidCircuitPathData::
        CardiovascularRegion (const CardiovascularRegion_optional& x)
        {
          this->CardiovascularRegion_ = x;
        }

        void FluidCircuitPathData::
        CardiovascularRegion (::std::unique_ptr< CardiovascularRegion_type > x)
        {
          this->CardiovascularRegion_.set (std::move (x));
        }

        const FluidCircuitPathData::Compliance_optional& FluidCircuitPathData::
        Compliance () const
        {
          return this->Compliance_;
        }

        FluidCircuitPathData::Compliance_optional& FluidCircuitPathData::
        Compliance ()
        {
          return this->Compliance_;
        }

        void FluidCircuitPathData::
        Compliance (const Compliance_type& x)
        {
          this->Compliance_.set (x);
        }

        void FluidCircuitPathData::
        Compliance (const Compliance_optional& x)
        {
          this->Compliance_ = x;
        }

        void FluidCircuitPathData::
        Compliance (::std::unique_ptr< Compliance_type > x)
        {
          this->Compliance_.set (std::move (x));
        }

        const FluidCircuitPathData::NextCompliance_optional& FluidCircuitPathData::
        NextCompliance () const
        {
          return this->NextCompliance_;
        }

        FluidCircuitPathData::NextCompliance_optional& FluidCircuitPathData::
        NextCompliance ()
        {
          return this->NextCompliance_;
        }

        void FluidCircuitPathData::
        NextCompliance (const NextCompliance_type& x)
        {
          this->NextCompliance_.set (x);
        }

        void FluidCircuitPathData::
        NextCompliance (const NextCompliance_optional& x)
        {
          this->NextCompliance_ = x;
        }

        void FluidCircuitPathData::
        NextCompliance (::std::unique_ptr< NextCompliance_type > x)
        {
          this->NextCompliance_.set (std::move (x));
        }

        const FluidCircuitPathData::ComplianceBaseline_optional& FluidCircuitPathData::
        ComplianceBaseline () const
        {
          return this->ComplianceBaseline_;
        }

        FluidCircuitPathData::ComplianceBaseline_optional& FluidCircuitPathData::
        ComplianceBaseline ()
        {
          return this->ComplianceBaseline_;
        }

        void FluidCircuitPathData::
        ComplianceBaseline (const ComplianceBaseline_type& x)
        {
          this->ComplianceBaseline_.set (x);
        }

        void FluidCircuitPathData::
        ComplianceBaseline (const ComplianceBaseline_optional& x)
        {
          this->ComplianceBaseline_ = x;
        }

        void FluidCircuitPathData::
        ComplianceBaseline (::std::unique_ptr< ComplianceBaseline_type > x)
        {
          this->ComplianceBaseline_.set (std::move (x));
        }

        const FluidCircuitPathData::Inertance_optional& FluidCircuitPathData::
        Inertance () const
        {
          return this->Inertance_;
        }

        FluidCircuitPathData::Inertance_optional& FluidCircuitPathData::
        Inertance ()
        {
          return this->Inertance_;
        }

        void FluidCircuitPathData::
        Inertance (const Inertance_type& x)
        {
          this->Inertance_.set (x);
        }

        void FluidCircuitPathData::
        Inertance (const Inertance_optional& x)
        {
          this->Inertance_ = x;
        }

        void FluidCircuitPathData::
        Inertance (::std::unique_ptr< Inertance_type > x)
        {
          this->Inertance_.set (std::move (x));
        }

        const FluidCircuitPathData::NextInertance_optional& FluidCircuitPathData::
        NextInertance () const
        {
          return this->NextInertance_;
        }

        FluidCircuitPathData::NextInertance_optional& FluidCircuitPathData::
        NextInertance ()
        {
          return this->NextInertance_;
        }

        void FluidCircuitPathData::
        NextInertance (const NextInertance_type& x)
        {
          this->NextInertance_.set (x);
        }

        void FluidCircuitPathData::
        NextInertance (const NextInertance_optional& x)
        {
          this->NextInertance_ = x;
        }

        void FluidCircuitPathData::
        NextInertance (::std::unique_ptr< NextInertance_type > x)
        {
          this->NextInertance_.set (std::move (x));
        }

        const FluidCircuitPathData::InertanceBaseline_optional& FluidCircuitPathData::
        InertanceBaseline () const
        {
          return this->InertanceBaseline_;
        }

        FluidCircuitPathData::InertanceBaseline_optional& FluidCircuitPathData::
        InertanceBaseline ()
        {
          return this->InertanceBaseline_;
        }

        void FluidCircuitPathData::
        InertanceBaseline (const InertanceBaseline_type& x)
        {
          this->InertanceBaseline_.set (x);
        }

        void FluidCircuitPathData::
        InertanceBaseline (const InertanceBaseline_optional& x)
        {
          this->InertanceBaseline_ = x;
        }

        void FluidCircuitPathData::
        InertanceBaseline (::std::unique_ptr< InertanceBaseline_type > x)
        {
          this->InertanceBaseline_.set (std::move (x));
        }

        const FluidCircuitPathData::Flow_optional& FluidCircuitPathData::
        Flow () const
        {
          return this->Flow_;
        }

        FluidCircuitPathData::Flow_optional& FluidCircuitPathData::
        Flow ()
        {
          return this->Flow_;
        }

        void FluidCircuitPathData::
        Flow (const Flow_type& x)
        {
          this->Flow_.set (x);
        }

        void FluidCircuitPathData::
        Flow (const Flow_optional& x)
        {
          this->Flow_ = x;
        }

        void FluidCircuitPathData::
        Flow (::std::unique_ptr< Flow_type > x)
        {
          this->Flow_.set (std::move (x));
        }

        const FluidCircuitPathData::NextFlow_optional& FluidCircuitPathData::
        NextFlow () const
        {
          return this->NextFlow_;
        }

        FluidCircuitPathData::NextFlow_optional& FluidCircuitPathData::
        NextFlow ()
        {
          return this->NextFlow_;
        }

        void FluidCircuitPathData::
        NextFlow (const NextFlow_type& x)
        {
          this->NextFlow_.set (x);
        }

        void FluidCircuitPathData::
        NextFlow (const NextFlow_optional& x)
        {
          this->NextFlow_ = x;
        }

        void FluidCircuitPathData::
        NextFlow (::std::unique_ptr< NextFlow_type > x)
        {
          this->NextFlow_.set (std::move (x));
        }

        const FluidCircuitPathData::FlowSource_optional& FluidCircuitPathData::
        FlowSource () const
        {
          return this->FlowSource_;
        }

        FluidCircuitPathData::FlowSource_optional& FluidCircuitPathData::
        FlowSource ()
        {
          return this->FlowSource_;
        }

        void FluidCircuitPathData::
        FlowSource (const FlowSource_type& x)
        {
          this->FlowSource_.set (x);
        }

        void FluidCircuitPathData::
        FlowSource (const FlowSource_optional& x)
        {
          this->FlowSource_ = x;
        }

        void FluidCircuitPathData::
        FlowSource (::std::unique_ptr< FlowSource_type > x)
        {
          this->FlowSource_.set (std::move (x));
        }

        const FluidCircuitPathData::NextFlowSource_optional& FluidCircuitPathData::
        NextFlowSource () const
        {
          return this->NextFlowSource_;
        }

        FluidCircuitPathData::NextFlowSource_optional& FluidCircuitPathData::
        NextFlowSource ()
        {
          return this->NextFlowSource_;
        }

        void FluidCircuitPathData::
        NextFlowSource (const NextFlowSource_type& x)
        {
          this->NextFlowSource_.set (x);
        }

        void FluidCircuitPathData::
        NextFlowSource (const NextFlowSource_optional& x)
        {
          this->NextFlowSource_ = x;
        }

        void FluidCircuitPathData::
        NextFlowSource (::std::unique_ptr< NextFlowSource_type > x)
        {
          this->NextFlowSource_.set (std::move (x));
        }

        const FluidCircuitPathData::FlowSourceBaseline_optional& FluidCircuitPathData::
        FlowSourceBaseline () const
        {
          return this->FlowSourceBaseline_;
        }

        FluidCircuitPathData::FlowSourceBaseline_optional& FluidCircuitPathData::
        FlowSourceBaseline ()
        {
          return this->FlowSourceBaseline_;
        }

        void FluidCircuitPathData::
        FlowSourceBaseline (const FlowSourceBaseline_type& x)
        {
          this->FlowSourceBaseline_.set (x);
        }

        void FluidCircuitPathData::
        FlowSourceBaseline (const FlowSourceBaseline_optional& x)
        {
          this->FlowSourceBaseline_ = x;
        }

        void FluidCircuitPathData::
        FlowSourceBaseline (::std::unique_ptr< FlowSourceBaseline_type > x)
        {
          this->FlowSourceBaseline_.set (std::move (x));
        }

        const FluidCircuitPathData::PressureSource_optional& FluidCircuitPathData::
        PressureSource () const
        {
          return this->PressureSource_;
        }

        FluidCircuitPathData::PressureSource_optional& FluidCircuitPathData::
        PressureSource ()
        {
          return this->PressureSource_;
        }

        void FluidCircuitPathData::
        PressureSource (const PressureSource_type& x)
        {
          this->PressureSource_.set (x);
        }

        void FluidCircuitPathData::
        PressureSource (const PressureSource_optional& x)
        {
          this->PressureSource_ = x;
        }

        void FluidCircuitPathData::
        PressureSource (::std::unique_ptr< PressureSource_type > x)
        {
          this->PressureSource_.set (std::move (x));
        }

        const FluidCircuitPathData::NextPressureSource_optional& FluidCircuitPathData::
        NextPressureSource () const
        {
          return this->NextPressureSource_;
        }

        FluidCircuitPathData::NextPressureSource_optional& FluidCircuitPathData::
        NextPressureSource ()
        {
          return this->NextPressureSource_;
        }

        void FluidCircuitPathData::
        NextPressureSource (const NextPressureSource_type& x)
        {
          this->NextPressureSource_.set (x);
        }

        void FluidCircuitPathData::
        NextPressureSource (const NextPressureSource_optional& x)
        {
          this->NextPressureSource_ = x;
        }

        void FluidCircuitPathData::
        NextPressureSource (::std::unique_ptr< NextPressureSource_type > x)
        {
          this->NextPressureSource_.set (std::move (x));
        }

        const FluidCircuitPathData::PressureSourceBaseline_optional& FluidCircuitPathData::
        PressureSourceBaseline () const
        {
          return this->PressureSourceBaseline_;
        }

        FluidCircuitPathData::PressureSourceBaseline_optional& FluidCircuitPathData::
        PressureSourceBaseline ()
        {
          return this->PressureSourceBaseline_;
        }

        void FluidCircuitPathData::
        PressureSourceBaseline (const PressureSourceBaseline_type& x)
        {
          this->PressureSourceBaseline_.set (x);
        }

        void FluidCircuitPathData::
        PressureSourceBaseline (const PressureSourceBaseline_optional& x)
        {
          this->PressureSourceBaseline_ = x;
        }

        void FluidCircuitPathData::
        PressureSourceBaseline (::std::unique_ptr< PressureSourceBaseline_type > x)
        {
          this->PressureSourceBaseline_.set (std::move (x));
        }

        const FluidCircuitPathData::ValveBreakdownPressure_optional& FluidCircuitPathData::
        ValveBreakdownPressure () const
        {
          return this->ValveBreakdownPressure_;
        }

        FluidCircuitPathData::ValveBreakdownPressure_optional& FluidCircuitPathData::
        ValveBreakdownPressure ()
        {
          return this->ValveBreakdownPressure_;
        }

        void FluidCircuitPathData::
        ValveBreakdownPressure (const ValveBreakdownPressure_type& x)
        {
          this->ValveBreakdownPressure_.set (x);
        }

        void FluidCircuitPathData::
        ValveBreakdownPressure (const ValveBreakdownPressure_optional& x)
        {
          this->ValveBreakdownPressure_ = x;
        }

        void FluidCircuitPathData::
        ValveBreakdownPressure (::std::unique_ptr< ValveBreakdownPressure_type > x)
        {
          this->ValveBreakdownPressure_.set (std::move (x));
        }


        // ThermalCircuitData
        // 

        const ThermalCircuitData::Node_sequence& ThermalCircuitData::
        Node () const
        {
          return this->Node_;
        }

        ThermalCircuitData::Node_sequence& ThermalCircuitData::
        Node ()
        {
          return this->Node_;
        }

        void ThermalCircuitData::
        Node (const Node_sequence& s)
        {
          this->Node_ = s;
        }

        const ThermalCircuitData::Path_sequence& ThermalCircuitData::
        Path () const
        {
          return this->Path_;
        }

        ThermalCircuitData::Path_sequence& ThermalCircuitData::
        Path ()
        {
          return this->Path_;
        }

        void ThermalCircuitData::
        Path (const Path_sequence& s)
        {
          this->Path_ = s;
        }


        // ThermalCircuitNodeData
        // 

        const ThermalCircuitNodeData::Temperature_optional& ThermalCircuitNodeData::
        Temperature () const
        {
          return this->Temperature_;
        }

        ThermalCircuitNodeData::Temperature_optional& ThermalCircuitNodeData::
        Temperature ()
        {
          return this->Temperature_;
        }

        void ThermalCircuitNodeData::
        Temperature (const Temperature_type& x)
        {
          this->Temperature_.set (x);
        }

        void ThermalCircuitNodeData::
        Temperature (const Temperature_optional& x)
        {
          this->Temperature_ = x;
        }

        void ThermalCircuitNodeData::
        Temperature (::std::unique_ptr< Temperature_type > x)
        {
          this->Temperature_.set (std::move (x));
        }

        const ThermalCircuitNodeData::NextTemperature_optional& ThermalCircuitNodeData::
        NextTemperature () const
        {
          return this->NextTemperature_;
        }

        ThermalCircuitNodeData::NextTemperature_optional& ThermalCircuitNodeData::
        NextTemperature ()
        {
          return this->NextTemperature_;
        }

        void ThermalCircuitNodeData::
        NextTemperature (const NextTemperature_type& x)
        {
          this->NextTemperature_.set (x);
        }

        void ThermalCircuitNodeData::
        NextTemperature (const NextTemperature_optional& x)
        {
          this->NextTemperature_ = x;
        }

        void ThermalCircuitNodeData::
        NextTemperature (::std::unique_ptr< NextTemperature_type > x)
        {
          this->NextTemperature_.set (std::move (x));
        }

        const ThermalCircuitNodeData::Heat_optional& ThermalCircuitNodeData::
        Heat () const
        {
          return this->Heat_;
        }

        ThermalCircuitNodeData::Heat_optional& ThermalCircuitNodeData::
        Heat ()
        {
          return this->Heat_;
        }

        void ThermalCircuitNodeData::
        Heat (const Heat_type& x)
        {
          this->Heat_.set (x);
        }

        void ThermalCircuitNodeData::
        Heat (const Heat_optional& x)
        {
          this->Heat_ = x;
        }

        void ThermalCircuitNodeData::
        Heat (::std::unique_ptr< Heat_type > x)
        {
          this->Heat_.set (std::move (x));
        }

        const ThermalCircuitNodeData::NextHeat_optional& ThermalCircuitNodeData::
        NextHeat () const
        {
          return this->NextHeat_;
        }

        ThermalCircuitNodeData::NextHeat_optional& ThermalCircuitNodeData::
        NextHeat ()
        {
          return this->NextHeat_;
        }

        void ThermalCircuitNodeData::
        NextHeat (const NextHeat_type& x)
        {
          this->NextHeat_.set (x);
        }

        void ThermalCircuitNodeData::
        NextHeat (const NextHeat_optional& x)
        {
          this->NextHeat_ = x;
        }

        void ThermalCircuitNodeData::
        NextHeat (::std::unique_ptr< NextHeat_type > x)
        {
          this->NextHeat_.set (std::move (x));
        }

        const ThermalCircuitNodeData::HeatBaseline_optional& ThermalCircuitNodeData::
        HeatBaseline () const
        {
          return this->HeatBaseline_;
        }

        ThermalCircuitNodeData::HeatBaseline_optional& ThermalCircuitNodeData::
        HeatBaseline ()
        {
          return this->HeatBaseline_;
        }

        void ThermalCircuitNodeData::
        HeatBaseline (const HeatBaseline_type& x)
        {
          this->HeatBaseline_.set (x);
        }

        void ThermalCircuitNodeData::
        HeatBaseline (const HeatBaseline_optional& x)
        {
          this->HeatBaseline_ = x;
        }

        void ThermalCircuitNodeData::
        HeatBaseline (::std::unique_ptr< HeatBaseline_type > x)
        {
          this->HeatBaseline_.set (std::move (x));
        }


        // ThermalCircuitPathData
        // 

        const ThermalCircuitPathData::Resistance_optional& ThermalCircuitPathData::
        Resistance () const
        {
          return this->Resistance_;
        }

        ThermalCircuitPathData::Resistance_optional& ThermalCircuitPathData::
        Resistance ()
        {
          return this->Resistance_;
        }

        void ThermalCircuitPathData::
        Resistance (const Resistance_type& x)
        {
          this->Resistance_.set (x);
        }

        void ThermalCircuitPathData::
        Resistance (const Resistance_optional& x)
        {
          this->Resistance_ = x;
        }

        void ThermalCircuitPathData::
        Resistance (::std::unique_ptr< Resistance_type > x)
        {
          this->Resistance_.set (std::move (x));
        }

        const ThermalCircuitPathData::NextResistance_optional& ThermalCircuitPathData::
        NextResistance () const
        {
          return this->NextResistance_;
        }

        ThermalCircuitPathData::NextResistance_optional& ThermalCircuitPathData::
        NextResistance ()
        {
          return this->NextResistance_;
        }

        void ThermalCircuitPathData::
        NextResistance (const NextResistance_type& x)
        {
          this->NextResistance_.set (x);
        }

        void ThermalCircuitPathData::
        NextResistance (const NextResistance_optional& x)
        {
          this->NextResistance_ = x;
        }

        void ThermalCircuitPathData::
        NextResistance (::std::unique_ptr< NextResistance_type > x)
        {
          this->NextResistance_.set (std::move (x));
        }

        const ThermalCircuitPathData::ResistanceBaseline_optional& ThermalCircuitPathData::
        ResistanceBaseline () const
        {
          return this->ResistanceBaseline_;
        }

        ThermalCircuitPathData::ResistanceBaseline_optional& ThermalCircuitPathData::
        ResistanceBaseline ()
        {
          return this->ResistanceBaseline_;
        }

        void ThermalCircuitPathData::
        ResistanceBaseline (const ResistanceBaseline_type& x)
        {
          this->ResistanceBaseline_.set (x);
        }

        void ThermalCircuitPathData::
        ResistanceBaseline (const ResistanceBaseline_optional& x)
        {
          this->ResistanceBaseline_ = x;
        }

        void ThermalCircuitPathData::
        ResistanceBaseline (::std::unique_ptr< ResistanceBaseline_type > x)
        {
          this->ResistanceBaseline_.set (std::move (x));
        }

        const ThermalCircuitPathData::Capacitance_optional& ThermalCircuitPathData::
        Capacitance () const
        {
          return this->Capacitance_;
        }

        ThermalCircuitPathData::Capacitance_optional& ThermalCircuitPathData::
        Capacitance ()
        {
          return this->Capacitance_;
        }

        void ThermalCircuitPathData::
        Capacitance (const Capacitance_type& x)
        {
          this->Capacitance_.set (x);
        }

        void ThermalCircuitPathData::
        Capacitance (const Capacitance_optional& x)
        {
          this->Capacitance_ = x;
        }

        void ThermalCircuitPathData::
        Capacitance (::std::unique_ptr< Capacitance_type > x)
        {
          this->Capacitance_.set (std::move (x));
        }

        const ThermalCircuitPathData::NextCapacitance_optional& ThermalCircuitPathData::
        NextCapacitance () const
        {
          return this->NextCapacitance_;
        }

        ThermalCircuitPathData::NextCapacitance_optional& ThermalCircuitPathData::
        NextCapacitance ()
        {
          return this->NextCapacitance_;
        }

        void ThermalCircuitPathData::
        NextCapacitance (const NextCapacitance_type& x)
        {
          this->NextCapacitance_.set (x);
        }

        void ThermalCircuitPathData::
        NextCapacitance (const NextCapacitance_optional& x)
        {
          this->NextCapacitance_ = x;
        }

        void ThermalCircuitPathData::
        NextCapacitance (::std::unique_ptr< NextCapacitance_type > x)
        {
          this->NextCapacitance_.set (std::move (x));
        }

        const ThermalCircuitPathData::CapacitanceBaseline_optional& ThermalCircuitPathData::
        CapacitanceBaseline () const
        {
          return this->CapacitanceBaseline_;
        }

        ThermalCircuitPathData::CapacitanceBaseline_optional& ThermalCircuitPathData::
        CapacitanceBaseline ()
        {
          return this->CapacitanceBaseline_;
        }

        void ThermalCircuitPathData::
        CapacitanceBaseline (const CapacitanceBaseline_type& x)
        {
          this->CapacitanceBaseline_.set (x);
        }

        void ThermalCircuitPathData::
        CapacitanceBaseline (const CapacitanceBaseline_optional& x)
        {
          this->CapacitanceBaseline_ = x;
        }

        void ThermalCircuitPathData::
        CapacitanceBaseline (::std::unique_ptr< CapacitanceBaseline_type > x)
        {
          this->CapacitanceBaseline_.set (std::move (x));
        }

        const ThermalCircuitPathData::Inductance_optional& ThermalCircuitPathData::
        Inductance () const
        {
          return this->Inductance_;
        }

        ThermalCircuitPathData::Inductance_optional& ThermalCircuitPathData::
        Inductance ()
        {
          return this->Inductance_;
        }

        void ThermalCircuitPathData::
        Inductance (const Inductance_type& x)
        {
          this->Inductance_.set (x);
        }

        void ThermalCircuitPathData::
        Inductance (const Inductance_optional& x)
        {
          this->Inductance_ = x;
        }

        void ThermalCircuitPathData::
        Inductance (::std::unique_ptr< Inductance_type > x)
        {
          this->Inductance_.set (std::move (x));
        }

        const ThermalCircuitPathData::NextInductance_optional& ThermalCircuitPathData::
        NextInductance () const
        {
          return this->NextInductance_;
        }

        ThermalCircuitPathData::NextInductance_optional& ThermalCircuitPathData::
        NextInductance ()
        {
          return this->NextInductance_;
        }

        void ThermalCircuitPathData::
        NextInductance (const NextInductance_type& x)
        {
          this->NextInductance_.set (x);
        }

        void ThermalCircuitPathData::
        NextInductance (const NextInductance_optional& x)
        {
          this->NextInductance_ = x;
        }

        void ThermalCircuitPathData::
        NextInductance (::std::unique_ptr< NextInductance_type > x)
        {
          this->NextInductance_.set (std::move (x));
        }

        const ThermalCircuitPathData::InductanceBaseline_optional& ThermalCircuitPathData::
        InductanceBaseline () const
        {
          return this->InductanceBaseline_;
        }

        ThermalCircuitPathData::InductanceBaseline_optional& ThermalCircuitPathData::
        InductanceBaseline ()
        {
          return this->InductanceBaseline_;
        }

        void ThermalCircuitPathData::
        InductanceBaseline (const InductanceBaseline_type& x)
        {
          this->InductanceBaseline_.set (x);
        }

        void ThermalCircuitPathData::
        InductanceBaseline (const InductanceBaseline_optional& x)
        {
          this->InductanceBaseline_ = x;
        }

        void ThermalCircuitPathData::
        InductanceBaseline (::std::unique_ptr< InductanceBaseline_type > x)
        {
          this->InductanceBaseline_.set (std::move (x));
        }

        const ThermalCircuitPathData::HeatTransferRate_optional& ThermalCircuitPathData::
        HeatTransferRate () const
        {
          return this->HeatTransferRate_;
        }

        ThermalCircuitPathData::HeatTransferRate_optional& ThermalCircuitPathData::
        HeatTransferRate ()
        {
          return this->HeatTransferRate_;
        }

        void ThermalCircuitPathData::
        HeatTransferRate (const HeatTransferRate_type& x)
        {
          this->HeatTransferRate_.set (x);
        }

        void ThermalCircuitPathData::
        HeatTransferRate (const HeatTransferRate_optional& x)
        {
          this->HeatTransferRate_ = x;
        }

        void ThermalCircuitPathData::
        HeatTransferRate (::std::unique_ptr< HeatTransferRate_type > x)
        {
          this->HeatTransferRate_.set (std::move (x));
        }

        const ThermalCircuitPathData::NextHeatTransferRate_optional& ThermalCircuitPathData::
        NextHeatTransferRate () const
        {
          return this->NextHeatTransferRate_;
        }

        ThermalCircuitPathData::NextHeatTransferRate_optional& ThermalCircuitPathData::
        NextHeatTransferRate ()
        {
          return this->NextHeatTransferRate_;
        }

        void ThermalCircuitPathData::
        NextHeatTransferRate (const NextHeatTransferRate_type& x)
        {
          this->NextHeatTransferRate_.set (x);
        }

        void ThermalCircuitPathData::
        NextHeatTransferRate (const NextHeatTransferRate_optional& x)
        {
          this->NextHeatTransferRate_ = x;
        }

        void ThermalCircuitPathData::
        NextHeatTransferRate (::std::unique_ptr< NextHeatTransferRate_type > x)
        {
          this->NextHeatTransferRate_.set (std::move (x));
        }

        const ThermalCircuitPathData::HeatSource_optional& ThermalCircuitPathData::
        HeatSource () const
        {
          return this->HeatSource_;
        }

        ThermalCircuitPathData::HeatSource_optional& ThermalCircuitPathData::
        HeatSource ()
        {
          return this->HeatSource_;
        }

        void ThermalCircuitPathData::
        HeatSource (const HeatSource_type& x)
        {
          this->HeatSource_.set (x);
        }

        void ThermalCircuitPathData::
        HeatSource (const HeatSource_optional& x)
        {
          this->HeatSource_ = x;
        }

        void ThermalCircuitPathData::
        HeatSource (::std::unique_ptr< HeatSource_type > x)
        {
          this->HeatSource_.set (std::move (x));
        }

        const ThermalCircuitPathData::NextHeatSource_optional& ThermalCircuitPathData::
        NextHeatSource () const
        {
          return this->NextHeatSource_;
        }

        ThermalCircuitPathData::NextHeatSource_optional& ThermalCircuitPathData::
        NextHeatSource ()
        {
          return this->NextHeatSource_;
        }

        void ThermalCircuitPathData::
        NextHeatSource (const NextHeatSource_type& x)
        {
          this->NextHeatSource_.set (x);
        }

        void ThermalCircuitPathData::
        NextHeatSource (const NextHeatSource_optional& x)
        {
          this->NextHeatSource_ = x;
        }

        void ThermalCircuitPathData::
        NextHeatSource (::std::unique_ptr< NextHeatSource_type > x)
        {
          this->NextHeatSource_.set (std::move (x));
        }

        const ThermalCircuitPathData::HeatSourceBaseline_optional& ThermalCircuitPathData::
        HeatSourceBaseline () const
        {
          return this->HeatSourceBaseline_;
        }

        ThermalCircuitPathData::HeatSourceBaseline_optional& ThermalCircuitPathData::
        HeatSourceBaseline ()
        {
          return this->HeatSourceBaseline_;
        }

        void ThermalCircuitPathData::
        HeatSourceBaseline (const HeatSourceBaseline_type& x)
        {
          this->HeatSourceBaseline_.set (x);
        }

        void ThermalCircuitPathData::
        HeatSourceBaseline (const HeatSourceBaseline_optional& x)
        {
          this->HeatSourceBaseline_ = x;
        }

        void ThermalCircuitPathData::
        HeatSourceBaseline (::std::unique_ptr< HeatSourceBaseline_type > x)
        {
          this->HeatSourceBaseline_.set (std::move (x));
        }

        const ThermalCircuitPathData::TemperatureSource_optional& ThermalCircuitPathData::
        TemperatureSource () const
        {
          return this->TemperatureSource_;
        }

        ThermalCircuitPathData::TemperatureSource_optional& ThermalCircuitPathData::
        TemperatureSource ()
        {
          return this->TemperatureSource_;
        }

        void ThermalCircuitPathData::
        TemperatureSource (const TemperatureSource_type& x)
        {
          this->TemperatureSource_.set (x);
        }

        void ThermalCircuitPathData::
        TemperatureSource (const TemperatureSource_optional& x)
        {
          this->TemperatureSource_ = x;
        }

        void ThermalCircuitPathData::
        TemperatureSource (::std::unique_ptr< TemperatureSource_type > x)
        {
          this->TemperatureSource_.set (std::move (x));
        }

        const ThermalCircuitPathData::NextTemperatureSource_optional& ThermalCircuitPathData::
        NextTemperatureSource () const
        {
          return this->NextTemperatureSource_;
        }

        ThermalCircuitPathData::NextTemperatureSource_optional& ThermalCircuitPathData::
        NextTemperatureSource ()
        {
          return this->NextTemperatureSource_;
        }

        void ThermalCircuitPathData::
        NextTemperatureSource (const NextTemperatureSource_type& x)
        {
          this->NextTemperatureSource_.set (x);
        }

        void ThermalCircuitPathData::
        NextTemperatureSource (const NextTemperatureSource_optional& x)
        {
          this->NextTemperatureSource_ = x;
        }

        void ThermalCircuitPathData::
        NextTemperatureSource (::std::unique_ptr< NextTemperatureSource_type > x)
        {
          this->NextTemperatureSource_.set (std::move (x));
        }

        const ThermalCircuitPathData::TemperatureSourceBaseline_optional& ThermalCircuitPathData::
        TemperatureSourceBaseline () const
        {
          return this->TemperatureSourceBaseline_;
        }

        ThermalCircuitPathData::TemperatureSourceBaseline_optional& ThermalCircuitPathData::
        TemperatureSourceBaseline ()
        {
          return this->TemperatureSourceBaseline_;
        }

        void ThermalCircuitPathData::
        TemperatureSourceBaseline (const TemperatureSourceBaseline_type& x)
        {
          this->TemperatureSourceBaseline_.set (x);
        }

        void ThermalCircuitPathData::
        TemperatureSourceBaseline (const TemperatureSourceBaseline_optional& x)
        {
          this->TemperatureSourceBaseline_ = x;
        }

        void ThermalCircuitPathData::
        TemperatureSourceBaseline (::std::unique_ptr< TemperatureSourceBaseline_type > x)
        {
          this->TemperatureSourceBaseline_.set (std::move (x));
        }

        const ThermalCircuitPathData::ValveBreakdownTemperature_optional& ThermalCircuitPathData::
        ValveBreakdownTemperature () const
        {
          return this->ValveBreakdownTemperature_;
        }

        ThermalCircuitPathData::ValveBreakdownTemperature_optional& ThermalCircuitPathData::
        ValveBreakdownTemperature ()
        {
          return this->ValveBreakdownTemperature_;
        }

        void ThermalCircuitPathData::
        ValveBreakdownTemperature (const ValveBreakdownTemperature_type& x)
        {
          this->ValveBreakdownTemperature_.set (x);
        }

        void ThermalCircuitPathData::
        ValveBreakdownTemperature (const ValveBreakdownTemperature_optional& x)
        {
          this->ValveBreakdownTemperature_ = x;
        }

        void ThermalCircuitPathData::
        ValveBreakdownTemperature (::std::unique_ptr< ValveBreakdownTemperature_type > x)
        {
          this->ValveBreakdownTemperature_.set (std::move (x));
        }


        // CircuitManagerData
        // 

        const CircuitManagerData::ElectricalNode_sequence& CircuitManagerData::
        ElectricalNode () const
        {
          return this->ElectricalNode_;
        }

        CircuitManagerData::ElectricalNode_sequence& CircuitManagerData::
        ElectricalNode ()
        {
          return this->ElectricalNode_;
        }

        void CircuitManagerData::
        ElectricalNode (const ElectricalNode_sequence& s)
        {
          this->ElectricalNode_ = s;
        }

        const CircuitManagerData::ElectricalPath_sequence& CircuitManagerData::
        ElectricalPath () const
        {
          return this->ElectricalPath_;
        }

        CircuitManagerData::ElectricalPath_sequence& CircuitManagerData::
        ElectricalPath ()
        {
          return this->ElectricalPath_;
        }

        void CircuitManagerData::
        ElectricalPath (const ElectricalPath_sequence& s)
        {
          this->ElectricalPath_ = s;
        }

        const CircuitManagerData::ElectricalCircuit_sequence& CircuitManagerData::
        ElectricalCircuit () const
        {
          return this->ElectricalCircuit_;
        }

        CircuitManagerData::ElectricalCircuit_sequence& CircuitManagerData::
        ElectricalCircuit ()
        {
          return this->ElectricalCircuit_;
        }

        void CircuitManagerData::
        ElectricalCircuit (const ElectricalCircuit_sequence& s)
        {
          this->ElectricalCircuit_ = s;
        }

        const CircuitManagerData::FluidNode_sequence& CircuitManagerData::
        FluidNode () const
        {
          return this->FluidNode_;
        }

        CircuitManagerData::FluidNode_sequence& CircuitManagerData::
        FluidNode ()
        {
          return this->FluidNode_;
        }

        void CircuitManagerData::
        FluidNode (const FluidNode_sequence& s)
        {
          this->FluidNode_ = s;
        }

        const CircuitManagerData::FluidPath_sequence& CircuitManagerData::
        FluidPath () const
        {
          return this->FluidPath_;
        }

        CircuitManagerData::FluidPath_sequence& CircuitManagerData::
        FluidPath ()
        {
          return this->FluidPath_;
        }

        void CircuitManagerData::
        FluidPath (const FluidPath_sequence& s)
        {
          this->FluidPath_ = s;
        }

        const CircuitManagerData::FluidCircuit_sequence& CircuitManagerData::
        FluidCircuit () const
        {
          return this->FluidCircuit_;
        }

        CircuitManagerData::FluidCircuit_sequence& CircuitManagerData::
        FluidCircuit ()
        {
          return this->FluidCircuit_;
        }

        void CircuitManagerData::
        FluidCircuit (const FluidCircuit_sequence& s)
        {
          this->FluidCircuit_ = s;
        }

        const CircuitManagerData::ThermalNode_sequence& CircuitManagerData::
        ThermalNode () const
        {
          return this->ThermalNode_;
        }

        CircuitManagerData::ThermalNode_sequence& CircuitManagerData::
        ThermalNode ()
        {
          return this->ThermalNode_;
        }

        void CircuitManagerData::
        ThermalNode (const ThermalNode_sequence& s)
        {
          this->ThermalNode_ = s;
        }

        const CircuitManagerData::ThermalPath_sequence& CircuitManagerData::
        ThermalPath () const
        {
          return this->ThermalPath_;
        }

        CircuitManagerData::ThermalPath_sequence& CircuitManagerData::
        ThermalPath ()
        {
          return this->ThermalPath_;
        }

        void CircuitManagerData::
        ThermalPath (const ThermalPath_sequence& s)
        {
          this->ThermalPath_ = s;
        }

        const CircuitManagerData::ThermalCircuit_sequence& CircuitManagerData::
        ThermalCircuit () const
        {
          return this->ThermalCircuit_;
        }

        CircuitManagerData::ThermalCircuit_sequence& CircuitManagerData::
        ThermalCircuit ()
        {
          return this->ThermalCircuit_;
        }

        void CircuitManagerData::
        ThermalCircuit (const ThermalCircuit_sequence& s)
        {
          this->ThermalCircuit_ = s;
        }
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        // enumCircuitType
        //

        enumCircuitType::
        enumCircuitType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
        : ::xml_schema::string (e, f, c)
        {
          _xsd_enumCircuitType_convert ();
        }

        enumCircuitType::
        enumCircuitType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
        : ::xml_schema::string (a, f, c)
        {
          _xsd_enumCircuitType_convert ();
        }

        enumCircuitType::
        enumCircuitType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
        : ::xml_schema::string (s, e, f, c)
        {
          _xsd_enumCircuitType_convert ();
        }

        enumCircuitType* enumCircuitType::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class enumCircuitType (*this, f, c);
        }

        enumCircuitType::value enumCircuitType::
        _xsd_enumCircuitType_convert () const
        {
          ::xsd::cxx::tree::enum_comparator< char > c (_xsd_enumCircuitType_literals_);
          const value* i (::std::lower_bound (
                            _xsd_enumCircuitType_indexes_,
                            _xsd_enumCircuitType_indexes_ + 3,
                            *this,
                            c));

          if (i == _xsd_enumCircuitType_indexes_ + 3 || _xsd_enumCircuitType_literals_[*i] != *this)
          {
            throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
          }

          return *i;
        }

        const char* const enumCircuitType::
        _xsd_enumCircuitType_literals_[3] =
        {
          "Electrical",
          "Fluid",
          "Thermal"
        };

        const enumCircuitType::value enumCircuitType::
        _xsd_enumCircuitType_indexes_[3] =
        {
          ::mil::tatrc::physiology::datamodel::enumCircuitType::Electrical,
          ::mil::tatrc::physiology::datamodel::enumCircuitType::Fluid,
          ::mil::tatrc::physiology::datamodel::enumCircuitType::Thermal
        };

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, enumCircuitType >
        _xsd_enumCircuitType_type_factory_init (
          "enumCircuitType",
          "uri:/mil/tatrc/physiology/datamodel");

        // enumResistancePathType
        //

        enumResistancePathType::
        enumResistancePathType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
        : ::xml_schema::string (e, f, c)
        {
          _xsd_enumResistancePathType_convert ();
        }

        enumResistancePathType::
        enumResistancePathType (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
        : ::xml_schema::string (a, f, c)
        {
          _xsd_enumResistancePathType_convert ();
        }

        enumResistancePathType::
        enumResistancePathType (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
        : ::xml_schema::string (s, e, f, c)
        {
          _xsd_enumResistancePathType_convert ();
        }

        enumResistancePathType* enumResistancePathType::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class enumResistancePathType (*this, f, c);
        }

        enumResistancePathType::value enumResistancePathType::
        _xsd_enumResistancePathType_convert () const
        {
          ::xsd::cxx::tree::enum_comparator< char > c (_xsd_enumResistancePathType_literals_);
          const value* i (::std::lower_bound (
                            _xsd_enumResistancePathType_indexes_,
                            _xsd_enumResistancePathType_indexes_ + 5,
                            *this,
                            c));

          if (i == _xsd_enumResistancePathType_indexes_ + 5 || _xsd_enumResistancePathType_literals_[*i] != *this)
          {
            throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
          }

          return *i;
        }

        const char* const enumResistancePathType::
        _xsd_enumResistancePathType_literals_[5] =
        {
          "Cerebral",
          "Extrasplanchnic",
          "Muscle",
          "Splanchnic",
          "Myocardium"
        };

        const enumResistancePathType::value enumResistancePathType::
        _xsd_enumResistancePathType_indexes_[5] =
        {
          ::mil::tatrc::physiology::datamodel::enumResistancePathType::Cerebral,
          ::mil::tatrc::physiology::datamodel::enumResistancePathType::Extrasplanchnic,
          ::mil::tatrc::physiology::datamodel::enumResistancePathType::Muscle,
          ::mil::tatrc::physiology::datamodel::enumResistancePathType::Myocardium,
          ::mil::tatrc::physiology::datamodel::enumResistancePathType::Splanchnic
        };

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, enumResistancePathType >
        _xsd_enumResistancePathType_type_factory_init (
          "enumResistancePathType",
          "uri:/mil/tatrc/physiology/datamodel");

        // CircuitData
        //

        CircuitData::
        CircuitData ()
        : ::mil::tatrc::physiology::datamodel::ObjectData (),
          Name_ (this),
          ReferenceNode_ (this)
        {
        }

        CircuitData::
        CircuitData (const Name_type& Name)
        : ::mil::tatrc::physiology::datamodel::ObjectData (),
          Name_ (Name, this),
          ReferenceNode_ (this)
        {
        }

        CircuitData::
        CircuitData (::std::unique_ptr< Name_type > Name)
        : ::mil::tatrc::physiology::datamodel::ObjectData (),
          Name_ (std::move (Name), this),
          ReferenceNode_ (this)
        {
        }

        CircuitData::
        CircuitData (const CircuitData& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::ObjectData (x, f, c),
          Name_ (x.Name_, f, this),
          ReferenceNode_ (x.ReferenceNode_, f, this)
        {
        }

        CircuitData::
        CircuitData (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::ObjectData (e, f | ::xml_schema::flags::base, c),
          Name_ (this),
          ReferenceNode_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void CircuitData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::ObjectData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Name
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Name",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Name_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!Name_.present ())
                {
                  ::std::unique_ptr< Name_type > r (
                    dynamic_cast< Name_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Name_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ReferenceNode
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ReferenceNode",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ReferenceNode_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< ReferenceNode_type > r (
                  dynamic_cast< ReferenceNode_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->ReferenceNode_.push_back (::std::move (r));
                continue;
              }
            }

            break;
          }

          if (!Name_.present ())
          {
            throw ::xsd::cxx::tree::expected_element< char > (
              "Name",
              "uri:/mil/tatrc/physiology/datamodel");
          }
        }

        CircuitData* CircuitData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class CircuitData (*this, f, c);
        }

        CircuitData& CircuitData::
        operator= (const CircuitData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::ObjectData& > (*this) = x;
            this->Name_ = x.Name_;
            this->ReferenceNode_ = x.ReferenceNode_;
          }

          return *this;
        }

        CircuitData::
        ~CircuitData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, CircuitData >
        _xsd_CircuitData_type_factory_init (
          "CircuitData",
          "uri:/mil/tatrc/physiology/datamodel");

        // CircuitNodeData
        //

        CircuitNodeData::
        CircuitNodeData ()
        : ::mil::tatrc::physiology::datamodel::ObjectData (),
          Name_ (this)
        {
        }

        CircuitNodeData::
        CircuitNodeData (const Name_type& Name)
        : ::mil::tatrc::physiology::datamodel::ObjectData (),
          Name_ (Name, this)
        {
        }

        CircuitNodeData::
        CircuitNodeData (::std::unique_ptr< Name_type > Name)
        : ::mil::tatrc::physiology::datamodel::ObjectData (),
          Name_ (std::move (Name), this)
        {
        }

        CircuitNodeData::
        CircuitNodeData (const CircuitNodeData& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::ObjectData (x, f, c),
          Name_ (x.Name_, f, this)
        {
        }

        CircuitNodeData::
        CircuitNodeData (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::ObjectData (e, f | ::xml_schema::flags::base, c),
          Name_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void CircuitNodeData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::ObjectData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Name
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Name",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Name_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!Name_.present ())
                {
                  ::std::unique_ptr< Name_type > r (
                    dynamic_cast< Name_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Name_.set (::std::move (r));
                  continue;
                }
              }
            }

            break;
          }

          if (!Name_.present ())
          {
            throw ::xsd::cxx::tree::expected_element< char > (
              "Name",
              "uri:/mil/tatrc/physiology/datamodel");
          }
        }

        CircuitNodeData* CircuitNodeData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class CircuitNodeData (*this, f, c);
        }

        CircuitNodeData& CircuitNodeData::
        operator= (const CircuitNodeData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::ObjectData& > (*this) = x;
            this->Name_ = x.Name_;
          }

          return *this;
        }

        CircuitNodeData::
        ~CircuitNodeData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, CircuitNodeData >
        _xsd_CircuitNodeData_type_factory_init (
          "CircuitNodeData",
          "uri:/mil/tatrc/physiology/datamodel");

        // CircuitPathData
        //

        CircuitPathData::
        CircuitPathData ()
        : ::mil::tatrc::physiology::datamodel::ObjectData (),
          Name_ (this),
          SourceNode_ (this),
          TargetNode_ (this),
          Switch_ (this),
          NextSwitch_ (this),
          Valve_ (this),
          NextValve_ (this),
          PolarizedState_ (this),
          NextPolarizedState_ (this)
        {
        }

        CircuitPathData::
        CircuitPathData (const Name_type& Name,
                         const SourceNode_type& SourceNode,
                         const TargetNode_type& TargetNode)
        : ::mil::tatrc::physiology::datamodel::ObjectData (),
          Name_ (Name, this),
          SourceNode_ (SourceNode, this),
          TargetNode_ (TargetNode, this),
          Switch_ (this),
          NextSwitch_ (this),
          Valve_ (this),
          NextValve_ (this),
          PolarizedState_ (this),
          NextPolarizedState_ (this)
        {
        }

        CircuitPathData::
        CircuitPathData (::std::unique_ptr< Name_type > Name,
                         ::std::unique_ptr< SourceNode_type > SourceNode,
                         ::std::unique_ptr< TargetNode_type > TargetNode)
        : ::mil::tatrc::physiology::datamodel::ObjectData (),
          Name_ (std::move (Name), this),
          SourceNode_ (std::move (SourceNode), this),
          TargetNode_ (std::move (TargetNode), this),
          Switch_ (this),
          NextSwitch_ (this),
          Valve_ (this),
          NextValve_ (this),
          PolarizedState_ (this),
          NextPolarizedState_ (this)
        {
        }

        CircuitPathData::
        CircuitPathData (const CircuitPathData& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::ObjectData (x, f, c),
          Name_ (x.Name_, f, this),
          SourceNode_ (x.SourceNode_, f, this),
          TargetNode_ (x.TargetNode_, f, this),
          Switch_ (x.Switch_, f, this),
          NextSwitch_ (x.NextSwitch_, f, this),
          Valve_ (x.Valve_, f, this),
          NextValve_ (x.NextValve_, f, this),
          PolarizedState_ (x.PolarizedState_, f, this),
          NextPolarizedState_ (x.NextPolarizedState_, f, this)
        {
        }

        CircuitPathData::
        CircuitPathData (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::ObjectData (e, f | ::xml_schema::flags::base, c),
          Name_ (this),
          SourceNode_ (this),
          TargetNode_ (this),
          Switch_ (this),
          NextSwitch_ (this),
          Valve_ (this),
          NextValve_ (this),
          PolarizedState_ (this),
          NextPolarizedState_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void CircuitPathData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::ObjectData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Name
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Name",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Name_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!Name_.present ())
                {
                  ::std::unique_ptr< Name_type > r (
                    dynamic_cast< Name_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Name_.set (::std::move (r));
                  continue;
                }
              }
            }

            // SourceNode
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "SourceNode",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< SourceNode_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!SourceNode_.present ())
                {
                  ::std::unique_ptr< SourceNode_type > r (
                    dynamic_cast< SourceNode_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->SourceNode_.set (::std::move (r));
                  continue;
                }
              }
            }

            // TargetNode
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "TargetNode",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< TargetNode_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!TargetNode_.present ())
                {
                  ::std::unique_ptr< TargetNode_type > r (
                    dynamic_cast< TargetNode_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->TargetNode_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Switch
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Switch",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Switch_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Switch_)
                {
                  ::std::unique_ptr< Switch_type > r (
                    dynamic_cast< Switch_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Switch_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextSwitch
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextSwitch",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextSwitch_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextSwitch_)
                {
                  ::std::unique_ptr< NextSwitch_type > r (
                    dynamic_cast< NextSwitch_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextSwitch_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Valve
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Valve",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Valve_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Valve_)
                {
                  ::std::unique_ptr< Valve_type > r (
                    dynamic_cast< Valve_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Valve_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextValve
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextValve",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextValve_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextValve_)
                {
                  ::std::unique_ptr< NextValve_type > r (
                    dynamic_cast< NextValve_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextValve_.set (::std::move (r));
                  continue;
                }
              }
            }

            // PolarizedState
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "PolarizedState",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< PolarizedState_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->PolarizedState_)
                {
                  ::std::unique_ptr< PolarizedState_type > r (
                    dynamic_cast< PolarizedState_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->PolarizedState_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextPolarizedState
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextPolarizedState",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextPolarizedState_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextPolarizedState_)
                {
                  ::std::unique_ptr< NextPolarizedState_type > r (
                    dynamic_cast< NextPolarizedState_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextPolarizedState_.set (::std::move (r));
                  continue;
                }
              }
            }

            break;
          }

          if (!Name_.present ())
          {
            throw ::xsd::cxx::tree::expected_element< char > (
              "Name",
              "uri:/mil/tatrc/physiology/datamodel");
          }

          if (!SourceNode_.present ())
          {
            throw ::xsd::cxx::tree::expected_element< char > (
              "SourceNode",
              "uri:/mil/tatrc/physiology/datamodel");
          }

          if (!TargetNode_.present ())
          {
            throw ::xsd::cxx::tree::expected_element< char > (
              "TargetNode",
              "uri:/mil/tatrc/physiology/datamodel");
          }
        }

        CircuitPathData* CircuitPathData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class CircuitPathData (*this, f, c);
        }

        CircuitPathData& CircuitPathData::
        operator= (const CircuitPathData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::ObjectData& > (*this) = x;
            this->Name_ = x.Name_;
            this->SourceNode_ = x.SourceNode_;
            this->TargetNode_ = x.TargetNode_;
            this->Switch_ = x.Switch_;
            this->NextSwitch_ = x.NextSwitch_;
            this->Valve_ = x.Valve_;
            this->NextValve_ = x.NextValve_;
            this->PolarizedState_ = x.PolarizedState_;
            this->NextPolarizedState_ = x.NextPolarizedState_;
          }

          return *this;
        }

        CircuitPathData::
        ~CircuitPathData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, CircuitPathData >
        _xsd_CircuitPathData_type_factory_init (
          "CircuitPathData",
          "uri:/mil/tatrc/physiology/datamodel");

        // ElectricalCircuitData
        //

        ElectricalCircuitData::
        ElectricalCircuitData ()
        : ::mil::tatrc::physiology::datamodel::CircuitData (),
          Node_ (this),
          Path_ (this)
        {
        }

        ElectricalCircuitData::
        ElectricalCircuitData (const Name_type& Name)
        : ::mil::tatrc::physiology::datamodel::CircuitData (Name),
          Node_ (this),
          Path_ (this)
        {
        }

        ElectricalCircuitData::
        ElectricalCircuitData (::std::unique_ptr< Name_type > Name)
        : ::mil::tatrc::physiology::datamodel::CircuitData (std::move (Name)),
          Node_ (this),
          Path_ (this)
        {
        }

        ElectricalCircuitData::
        ElectricalCircuitData (const ElectricalCircuitData& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitData (x, f, c),
          Node_ (x.Node_, f, this),
          Path_ (x.Path_, f, this)
        {
        }

        ElectricalCircuitData::
        ElectricalCircuitData (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitData (e, f | ::xml_schema::flags::base, c),
          Node_ (this),
          Path_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void ElectricalCircuitData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::CircuitData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Node
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Node",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Node_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< Node_type > r (
                  dynamic_cast< Node_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->Node_.push_back (::std::move (r));
                continue;
              }
            }

            // Path
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Path",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Path_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< Path_type > r (
                  dynamic_cast< Path_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->Path_.push_back (::std::move (r));
                continue;
              }
            }

            break;
          }
        }

        ElectricalCircuitData* ElectricalCircuitData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class ElectricalCircuitData (*this, f, c);
        }

        ElectricalCircuitData& ElectricalCircuitData::
        operator= (const ElectricalCircuitData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::CircuitData& > (*this) = x;
            this->Node_ = x.Node_;
            this->Path_ = x.Path_;
          }

          return *this;
        }

        ElectricalCircuitData::
        ~ElectricalCircuitData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, ElectricalCircuitData >
        _xsd_ElectricalCircuitData_type_factory_init (
          "ElectricalCircuitData",
          "uri:/mil/tatrc/physiology/datamodel");

        // ElectricalCircuitNodeData
        //

        ElectricalCircuitNodeData::
        ElectricalCircuitNodeData ()
        : ::mil::tatrc::physiology::datamodel::CircuitNodeData (),
          Voltage_ (this),
          NextVoltage_ (this),
          Charge_ (this),
          NextCharge_ (this),
          ChargeBaseline_ (this)
        {
        }

        ElectricalCircuitNodeData::
        ElectricalCircuitNodeData (const Name_type& Name)
        : ::mil::tatrc::physiology::datamodel::CircuitNodeData (Name),
          Voltage_ (this),
          NextVoltage_ (this),
          Charge_ (this),
          NextCharge_ (this),
          ChargeBaseline_ (this)
        {
        }

        ElectricalCircuitNodeData::
        ElectricalCircuitNodeData (::std::unique_ptr< Name_type > Name)
        : ::mil::tatrc::physiology::datamodel::CircuitNodeData (std::move (Name)),
          Voltage_ (this),
          NextVoltage_ (this),
          Charge_ (this),
          NextCharge_ (this),
          ChargeBaseline_ (this)
        {
        }

        ElectricalCircuitNodeData::
        ElectricalCircuitNodeData (const ElectricalCircuitNodeData& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitNodeData (x, f, c),
          Voltage_ (x.Voltage_, f, this),
          NextVoltage_ (x.NextVoltage_, f, this),
          Charge_ (x.Charge_, f, this),
          NextCharge_ (x.NextCharge_, f, this),
          ChargeBaseline_ (x.ChargeBaseline_, f, this)
        {
        }

        ElectricalCircuitNodeData::
        ElectricalCircuitNodeData (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitNodeData (e, f | ::xml_schema::flags::base, c),
          Voltage_ (this),
          NextVoltage_ (this),
          Charge_ (this),
          NextCharge_ (this),
          ChargeBaseline_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void ElectricalCircuitNodeData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::CircuitNodeData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Voltage
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Voltage",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Voltage_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Voltage_)
                {
                  ::std::unique_ptr< Voltage_type > r (
                    dynamic_cast< Voltage_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Voltage_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextVoltage
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextVoltage",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextVoltage_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextVoltage_)
                {
                  ::std::unique_ptr< NextVoltage_type > r (
                    dynamic_cast< NextVoltage_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextVoltage_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Charge
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Charge",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Charge_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Charge_)
                {
                  ::std::unique_ptr< Charge_type > r (
                    dynamic_cast< Charge_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Charge_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextCharge
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextCharge",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextCharge_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextCharge_)
                {
                  ::std::unique_ptr< NextCharge_type > r (
                    dynamic_cast< NextCharge_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextCharge_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ChargeBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ChargeBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ChargeBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ChargeBaseline_)
                {
                  ::std::unique_ptr< ChargeBaseline_type > r (
                    dynamic_cast< ChargeBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ChargeBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            break;
          }
        }

        ElectricalCircuitNodeData* ElectricalCircuitNodeData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class ElectricalCircuitNodeData (*this, f, c);
        }

        ElectricalCircuitNodeData& ElectricalCircuitNodeData::
        operator= (const ElectricalCircuitNodeData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::CircuitNodeData& > (*this) = x;
            this->Voltage_ = x.Voltage_;
            this->NextVoltage_ = x.NextVoltage_;
            this->Charge_ = x.Charge_;
            this->NextCharge_ = x.NextCharge_;
            this->ChargeBaseline_ = x.ChargeBaseline_;
          }

          return *this;
        }

        ElectricalCircuitNodeData::
        ~ElectricalCircuitNodeData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, ElectricalCircuitNodeData >
        _xsd_ElectricalCircuitNodeData_type_factory_init (
          "ElectricalCircuitNodeData",
          "uri:/mil/tatrc/physiology/datamodel");

        // ElectricalCircuitPathData
        //

        ElectricalCircuitPathData::
        ElectricalCircuitPathData ()
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Capacitance_ (this),
          NextCapacitance_ (this),
          CapacitanceBaseline_ (this),
          Inductance_ (this),
          NextInductance_ (this),
          InductanceBaseline_ (this),
          Current_ (this),
          NextCurrent_ (this),
          CurrentSource_ (this),
          NextCurrentSource_ (this),
          CurrentSourceBaseline_ (this),
          VoltageSource_ (this),
          NextVoltageSource_ (this),
          VoltageSourceBaseline_ (this),
          ValveBreakdownVoltage_ (this)
        {
        }

        ElectricalCircuitPathData::
        ElectricalCircuitPathData (const Name_type& Name,
                                   const SourceNode_type& SourceNode,
                                   const TargetNode_type& TargetNode)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (Name,
                                                                SourceNode,
                                                                TargetNode),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Capacitance_ (this),
          NextCapacitance_ (this),
          CapacitanceBaseline_ (this),
          Inductance_ (this),
          NextInductance_ (this),
          InductanceBaseline_ (this),
          Current_ (this),
          NextCurrent_ (this),
          CurrentSource_ (this),
          NextCurrentSource_ (this),
          CurrentSourceBaseline_ (this),
          VoltageSource_ (this),
          NextVoltageSource_ (this),
          VoltageSourceBaseline_ (this),
          ValveBreakdownVoltage_ (this)
        {
        }

        ElectricalCircuitPathData::
        ElectricalCircuitPathData (::std::unique_ptr< Name_type > Name,
                                   ::std::unique_ptr< SourceNode_type > SourceNode,
                                   ::std::unique_ptr< TargetNode_type > TargetNode)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (std::move (Name),
                                                                std::move (SourceNode),
                                                                std::move (TargetNode)),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Capacitance_ (this),
          NextCapacitance_ (this),
          CapacitanceBaseline_ (this),
          Inductance_ (this),
          NextInductance_ (this),
          InductanceBaseline_ (this),
          Current_ (this),
          NextCurrent_ (this),
          CurrentSource_ (this),
          NextCurrentSource_ (this),
          CurrentSourceBaseline_ (this),
          VoltageSource_ (this),
          NextVoltageSource_ (this),
          VoltageSourceBaseline_ (this),
          ValveBreakdownVoltage_ (this)
        {
        }

        ElectricalCircuitPathData::
        ElectricalCircuitPathData (const ElectricalCircuitPathData& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (x, f, c),
          Resistance_ (x.Resistance_, f, this),
          NextResistance_ (x.NextResistance_, f, this),
          ResistanceBaseline_ (x.ResistanceBaseline_, f, this),
          Capacitance_ (x.Capacitance_, f, this),
          NextCapacitance_ (x.NextCapacitance_, f, this),
          CapacitanceBaseline_ (x.CapacitanceBaseline_, f, this),
          Inductance_ (x.Inductance_, f, this),
          NextInductance_ (x.NextInductance_, f, this),
          InductanceBaseline_ (x.InductanceBaseline_, f, this),
          Current_ (x.Current_, f, this),
          NextCurrent_ (x.NextCurrent_, f, this),
          CurrentSource_ (x.CurrentSource_, f, this),
          NextCurrentSource_ (x.NextCurrentSource_, f, this),
          CurrentSourceBaseline_ (x.CurrentSourceBaseline_, f, this),
          VoltageSource_ (x.VoltageSource_, f, this),
          NextVoltageSource_ (x.NextVoltageSource_, f, this),
          VoltageSourceBaseline_ (x.VoltageSourceBaseline_, f, this),
          ValveBreakdownVoltage_ (x.ValveBreakdownVoltage_, f, this)
        {
        }

        ElectricalCircuitPathData::
        ElectricalCircuitPathData (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (e, f | ::xml_schema::flags::base, c),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Capacitance_ (this),
          NextCapacitance_ (this),
          CapacitanceBaseline_ (this),
          Inductance_ (this),
          NextInductance_ (this),
          InductanceBaseline_ (this),
          Current_ (this),
          NextCurrent_ (this),
          CurrentSource_ (this),
          NextCurrentSource_ (this),
          CurrentSourceBaseline_ (this),
          VoltageSource_ (this),
          NextVoltageSource_ (this),
          VoltageSourceBaseline_ (this),
          ValveBreakdownVoltage_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void ElectricalCircuitPathData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::CircuitPathData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Resistance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Resistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Resistance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Resistance_)
                {
                  ::std::unique_ptr< Resistance_type > r (
                    dynamic_cast< Resistance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Resistance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextResistance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextResistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextResistance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextResistance_)
                {
                  ::std::unique_ptr< NextResistance_type > r (
                    dynamic_cast< NextResistance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextResistance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ResistanceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ResistanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ResistanceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ResistanceBaseline_)
                {
                  ::std::unique_ptr< ResistanceBaseline_type > r (
                    dynamic_cast< ResistanceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ResistanceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Capacitance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Capacitance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Capacitance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Capacitance_)
                {
                  ::std::unique_ptr< Capacitance_type > r (
                    dynamic_cast< Capacitance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Capacitance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextCapacitance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextCapacitance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextCapacitance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextCapacitance_)
                {
                  ::std::unique_ptr< NextCapacitance_type > r (
                    dynamic_cast< NextCapacitance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextCapacitance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // CapacitanceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "CapacitanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< CapacitanceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->CapacitanceBaseline_)
                {
                  ::std::unique_ptr< CapacitanceBaseline_type > r (
                    dynamic_cast< CapacitanceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->CapacitanceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Inductance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Inductance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Inductance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Inductance_)
                {
                  ::std::unique_ptr< Inductance_type > r (
                    dynamic_cast< Inductance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Inductance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextInductance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextInductance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextInductance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextInductance_)
                {
                  ::std::unique_ptr< NextInductance_type > r (
                    dynamic_cast< NextInductance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextInductance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // InductanceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "InductanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< InductanceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->InductanceBaseline_)
                {
                  ::std::unique_ptr< InductanceBaseline_type > r (
                    dynamic_cast< InductanceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->InductanceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Current
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Current",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Current_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Current_)
                {
                  ::std::unique_ptr< Current_type > r (
                    dynamic_cast< Current_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Current_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextCurrent
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextCurrent",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextCurrent_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextCurrent_)
                {
                  ::std::unique_ptr< NextCurrent_type > r (
                    dynamic_cast< NextCurrent_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextCurrent_.set (::std::move (r));
                  continue;
                }
              }
            }

            // CurrentSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "CurrentSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< CurrentSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->CurrentSource_)
                {
                  ::std::unique_ptr< CurrentSource_type > r (
                    dynamic_cast< CurrentSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->CurrentSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextCurrentSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextCurrentSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextCurrentSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextCurrentSource_)
                {
                  ::std::unique_ptr< NextCurrentSource_type > r (
                    dynamic_cast< NextCurrentSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextCurrentSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // CurrentSourceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "CurrentSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< CurrentSourceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->CurrentSourceBaseline_)
                {
                  ::std::unique_ptr< CurrentSourceBaseline_type > r (
                    dynamic_cast< CurrentSourceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->CurrentSourceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // VoltageSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "VoltageSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< VoltageSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->VoltageSource_)
                {
                  ::std::unique_ptr< VoltageSource_type > r (
                    dynamic_cast< VoltageSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->VoltageSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextVoltageSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextVoltageSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextVoltageSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextVoltageSource_)
                {
                  ::std::unique_ptr< NextVoltageSource_type > r (
                    dynamic_cast< NextVoltageSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextVoltageSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // VoltageSourceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "VoltageSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< VoltageSourceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->VoltageSourceBaseline_)
                {
                  ::std::unique_ptr< VoltageSourceBaseline_type > r (
                    dynamic_cast< VoltageSourceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->VoltageSourceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ValveBreakdownVoltage
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ValveBreakdownVoltage",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ValveBreakdownVoltage_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ValveBreakdownVoltage_)
                {
                  ::std::unique_ptr< ValveBreakdownVoltage_type > r (
                    dynamic_cast< ValveBreakdownVoltage_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ValveBreakdownVoltage_.set (::std::move (r));
                  continue;
                }
              }
            }

            break;
          }
        }

        ElectricalCircuitPathData* ElectricalCircuitPathData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class ElectricalCircuitPathData (*this, f, c);
        }

        ElectricalCircuitPathData& ElectricalCircuitPathData::
        operator= (const ElectricalCircuitPathData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::CircuitPathData& > (*this) = x;
            this->Resistance_ = x.Resistance_;
            this->NextResistance_ = x.NextResistance_;
            this->ResistanceBaseline_ = x.ResistanceBaseline_;
            this->Capacitance_ = x.Capacitance_;
            this->NextCapacitance_ = x.NextCapacitance_;
            this->CapacitanceBaseline_ = x.CapacitanceBaseline_;
            this->Inductance_ = x.Inductance_;
            this->NextInductance_ = x.NextInductance_;
            this->InductanceBaseline_ = x.InductanceBaseline_;
            this->Current_ = x.Current_;
            this->NextCurrent_ = x.NextCurrent_;
            this->CurrentSource_ = x.CurrentSource_;
            this->NextCurrentSource_ = x.NextCurrentSource_;
            this->CurrentSourceBaseline_ = x.CurrentSourceBaseline_;
            this->VoltageSource_ = x.VoltageSource_;
            this->NextVoltageSource_ = x.NextVoltageSource_;
            this->VoltageSourceBaseline_ = x.VoltageSourceBaseline_;
            this->ValveBreakdownVoltage_ = x.ValveBreakdownVoltage_;
          }

          return *this;
        }

        ElectricalCircuitPathData::
        ~ElectricalCircuitPathData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, ElectricalCircuitPathData >
        _xsd_ElectricalCircuitPathData_type_factory_init (
          "ElectricalCircuitPathData",
          "uri:/mil/tatrc/physiology/datamodel");

        // FluidCircuitData
        //

        FluidCircuitData::
        FluidCircuitData ()
        : ::mil::tatrc::physiology::datamodel::CircuitData (),
          Node_ (this),
          Path_ (this)
        {
        }

        FluidCircuitData::
        FluidCircuitData (const Name_type& Name)
        : ::mil::tatrc::physiology::datamodel::CircuitData (Name),
          Node_ (this),
          Path_ (this)
        {
        }

        FluidCircuitData::
        FluidCircuitData (::std::unique_ptr< Name_type > Name)
        : ::mil::tatrc::physiology::datamodel::CircuitData (std::move (Name)),
          Node_ (this),
          Path_ (this)
        {
        }

        FluidCircuitData::
        FluidCircuitData (const FluidCircuitData& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitData (x, f, c),
          Node_ (x.Node_, f, this),
          Path_ (x.Path_, f, this)
        {
        }

        FluidCircuitData::
        FluidCircuitData (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitData (e, f | ::xml_schema::flags::base, c),
          Node_ (this),
          Path_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void FluidCircuitData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::CircuitData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Node
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Node",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Node_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< Node_type > r (
                  dynamic_cast< Node_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->Node_.push_back (::std::move (r));
                continue;
              }
            }

            // Path
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Path",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Path_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< Path_type > r (
                  dynamic_cast< Path_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->Path_.push_back (::std::move (r));
                continue;
              }
            }

            break;
          }
        }

        FluidCircuitData* FluidCircuitData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class FluidCircuitData (*this, f, c);
        }

        FluidCircuitData& FluidCircuitData::
        operator= (const FluidCircuitData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::CircuitData& > (*this) = x;
            this->Node_ = x.Node_;
            this->Path_ = x.Path_;
          }

          return *this;
        }

        FluidCircuitData::
        ~FluidCircuitData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, FluidCircuitData >
        _xsd_FluidCircuitData_type_factory_init (
          "FluidCircuitData",
          "uri:/mil/tatrc/physiology/datamodel");

        // FluidCircuitNodeData
        //

        FluidCircuitNodeData::
        FluidCircuitNodeData ()
        : ::mil::tatrc::physiology::datamodel::CircuitNodeData (),
          Pressure_ (this),
          NextPressure_ (this),
          Volume_ (this),
          NextVolume_ (this),
          VolumeBaseline_ (this)
        {
        }

        FluidCircuitNodeData::
        FluidCircuitNodeData (const Name_type& Name)
        : ::mil::tatrc::physiology::datamodel::CircuitNodeData (Name),
          Pressure_ (this),
          NextPressure_ (this),
          Volume_ (this),
          NextVolume_ (this),
          VolumeBaseline_ (this)
        {
        }

        FluidCircuitNodeData::
        FluidCircuitNodeData (::std::unique_ptr< Name_type > Name)
        : ::mil::tatrc::physiology::datamodel::CircuitNodeData (std::move (Name)),
          Pressure_ (this),
          NextPressure_ (this),
          Volume_ (this),
          NextVolume_ (this),
          VolumeBaseline_ (this)
        {
        }

        FluidCircuitNodeData::
        FluidCircuitNodeData (const FluidCircuitNodeData& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitNodeData (x, f, c),
          Pressure_ (x.Pressure_, f, this),
          NextPressure_ (x.NextPressure_, f, this),
          Volume_ (x.Volume_, f, this),
          NextVolume_ (x.NextVolume_, f, this),
          VolumeBaseline_ (x.VolumeBaseline_, f, this)
        {
        }

        FluidCircuitNodeData::
        FluidCircuitNodeData (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitNodeData (e, f | ::xml_schema::flags::base, c),
          Pressure_ (this),
          NextPressure_ (this),
          Volume_ (this),
          NextVolume_ (this),
          VolumeBaseline_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void FluidCircuitNodeData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::CircuitNodeData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Pressure
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Pressure",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Pressure_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Pressure_)
                {
                  ::std::unique_ptr< Pressure_type > r (
                    dynamic_cast< Pressure_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Pressure_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextPressure
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextPressure",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextPressure_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextPressure_)
                {
                  ::std::unique_ptr< NextPressure_type > r (
                    dynamic_cast< NextPressure_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextPressure_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Volume
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Volume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Volume_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Volume_)
                {
                  ::std::unique_ptr< Volume_type > r (
                    dynamic_cast< Volume_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Volume_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextVolume
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextVolume_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextVolume_)
                {
                  ::std::unique_ptr< NextVolume_type > r (
                    dynamic_cast< NextVolume_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextVolume_.set (::std::move (r));
                  continue;
                }
              }
            }

            // VolumeBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "VolumeBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< VolumeBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->VolumeBaseline_)
                {
                  ::std::unique_ptr< VolumeBaseline_type > r (
                    dynamic_cast< VolumeBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->VolumeBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            break;
          }
        }

        FluidCircuitNodeData* FluidCircuitNodeData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class FluidCircuitNodeData (*this, f, c);
        }

        FluidCircuitNodeData& FluidCircuitNodeData::
        operator= (const FluidCircuitNodeData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::CircuitNodeData& > (*this) = x;
            this->Pressure_ = x.Pressure_;
            this->NextPressure_ = x.NextPressure_;
            this->Volume_ = x.Volume_;
            this->NextVolume_ = x.NextVolume_;
            this->VolumeBaseline_ = x.VolumeBaseline_;
          }

          return *this;
        }

        FluidCircuitNodeData::
        ~FluidCircuitNodeData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, FluidCircuitNodeData >
        _xsd_FluidCircuitNodeData_type_factory_init (
          "FluidCircuitNodeData",
          "uri:/mil/tatrc/physiology/datamodel");

        // FluidCircuitPathData
        //

        FluidCircuitPathData::
        FluidCircuitPathData ()
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          CardiovascularRegion_ (this),
          Compliance_ (this),
          NextCompliance_ (this),
          ComplianceBaseline_ (this),
          Inertance_ (this),
          NextInertance_ (this),
          InertanceBaseline_ (this),
          Flow_ (this),
          NextFlow_ (this),
          FlowSource_ (this),
          NextFlowSource_ (this),
          FlowSourceBaseline_ (this),
          PressureSource_ (this),
          NextPressureSource_ (this),
          PressureSourceBaseline_ (this),
          ValveBreakdownPressure_ (this)
        {
        }

        FluidCircuitPathData::
        FluidCircuitPathData (const Name_type& Name,
                              const SourceNode_type& SourceNode,
                              const TargetNode_type& TargetNode)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (Name,
                                                                SourceNode,
                                                                TargetNode),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          CardiovascularRegion_ (this),
          Compliance_ (this),
          NextCompliance_ (this),
          ComplianceBaseline_ (this),
          Inertance_ (this),
          NextInertance_ (this),
          InertanceBaseline_ (this),
          Flow_ (this),
          NextFlow_ (this),
          FlowSource_ (this),
          NextFlowSource_ (this),
          FlowSourceBaseline_ (this),
          PressureSource_ (this),
          NextPressureSource_ (this),
          PressureSourceBaseline_ (this),
          ValveBreakdownPressure_ (this)
        {
        }

        FluidCircuitPathData::
        FluidCircuitPathData (::std::unique_ptr< Name_type > Name,
                              ::std::unique_ptr< SourceNode_type > SourceNode,
                              ::std::unique_ptr< TargetNode_type > TargetNode)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (std::move (Name),
                                                                std::move (SourceNode),
                                                                std::move (TargetNode)),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          CardiovascularRegion_ (this),
          Compliance_ (this),
          NextCompliance_ (this),
          ComplianceBaseline_ (this),
          Inertance_ (this),
          NextInertance_ (this),
          InertanceBaseline_ (this),
          Flow_ (this),
          NextFlow_ (this),
          FlowSource_ (this),
          NextFlowSource_ (this),
          FlowSourceBaseline_ (this),
          PressureSource_ (this),
          NextPressureSource_ (this),
          PressureSourceBaseline_ (this),
          ValveBreakdownPressure_ (this)
        {
        }

        FluidCircuitPathData::
        FluidCircuitPathData (const FluidCircuitPathData& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (x, f, c),
          Resistance_ (x.Resistance_, f, this),
          NextResistance_ (x.NextResistance_, f, this),
          ResistanceBaseline_ (x.ResistanceBaseline_, f, this),
          CardiovascularRegion_ (x.CardiovascularRegion_, f, this),
          Compliance_ (x.Compliance_, f, this),
          NextCompliance_ (x.NextCompliance_, f, this),
          ComplianceBaseline_ (x.ComplianceBaseline_, f, this),
          Inertance_ (x.Inertance_, f, this),
          NextInertance_ (x.NextInertance_, f, this),
          InertanceBaseline_ (x.InertanceBaseline_, f, this),
          Flow_ (x.Flow_, f, this),
          NextFlow_ (x.NextFlow_, f, this),
          FlowSource_ (x.FlowSource_, f, this),
          NextFlowSource_ (x.NextFlowSource_, f, this),
          FlowSourceBaseline_ (x.FlowSourceBaseline_, f, this),
          PressureSource_ (x.PressureSource_, f, this),
          NextPressureSource_ (x.NextPressureSource_, f, this),
          PressureSourceBaseline_ (x.PressureSourceBaseline_, f, this),
          ValveBreakdownPressure_ (x.ValveBreakdownPressure_, f, this)
        {
        }

        FluidCircuitPathData::
        FluidCircuitPathData (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (e, f | ::xml_schema::flags::base, c),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          CardiovascularRegion_ (this),
          Compliance_ (this),
          NextCompliance_ (this),
          ComplianceBaseline_ (this),
          Inertance_ (this),
          NextInertance_ (this),
          InertanceBaseline_ (this),
          Flow_ (this),
          NextFlow_ (this),
          FlowSource_ (this),
          NextFlowSource_ (this),
          FlowSourceBaseline_ (this),
          PressureSource_ (this),
          NextPressureSource_ (this),
          PressureSourceBaseline_ (this),
          ValveBreakdownPressure_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void FluidCircuitPathData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::CircuitPathData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Resistance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Resistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Resistance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Resistance_)
                {
                  ::std::unique_ptr< Resistance_type > r (
                    dynamic_cast< Resistance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Resistance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextResistance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextResistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextResistance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextResistance_)
                {
                  ::std::unique_ptr< NextResistance_type > r (
                    dynamic_cast< NextResistance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextResistance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ResistanceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ResistanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ResistanceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ResistanceBaseline_)
                {
                  ::std::unique_ptr< ResistanceBaseline_type > r (
                    dynamic_cast< ResistanceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ResistanceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // CardiovascularRegion
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "CardiovascularRegion",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< CardiovascularRegion_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->CardiovascularRegion_)
                {
                  ::std::unique_ptr< CardiovascularRegion_type > r (
                    dynamic_cast< CardiovascularRegion_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->CardiovascularRegion_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Compliance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Compliance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Compliance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Compliance_)
                {
                  ::std::unique_ptr< Compliance_type > r (
                    dynamic_cast< Compliance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Compliance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextCompliance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextCompliance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextCompliance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextCompliance_)
                {
                  ::std::unique_ptr< NextCompliance_type > r (
                    dynamic_cast< NextCompliance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextCompliance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ComplianceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ComplianceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ComplianceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ComplianceBaseline_)
                {
                  ::std::unique_ptr< ComplianceBaseline_type > r (
                    dynamic_cast< ComplianceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ComplianceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Inertance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Inertance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Inertance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Inertance_)
                {
                  ::std::unique_ptr< Inertance_type > r (
                    dynamic_cast< Inertance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Inertance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextInertance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextInertance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextInertance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextInertance_)
                {
                  ::std::unique_ptr< NextInertance_type > r (
                    dynamic_cast< NextInertance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextInertance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // InertanceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "InertanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< InertanceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->InertanceBaseline_)
                {
                  ::std::unique_ptr< InertanceBaseline_type > r (
                    dynamic_cast< InertanceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->InertanceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Flow
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Flow",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Flow_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Flow_)
                {
                  ::std::unique_ptr< Flow_type > r (
                    dynamic_cast< Flow_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Flow_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextFlow
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextFlow",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextFlow_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextFlow_)
                {
                  ::std::unique_ptr< NextFlow_type > r (
                    dynamic_cast< NextFlow_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextFlow_.set (::std::move (r));
                  continue;
                }
              }
            }

            // FlowSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "FlowSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< FlowSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->FlowSource_)
                {
                  ::std::unique_ptr< FlowSource_type > r (
                    dynamic_cast< FlowSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->FlowSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextFlowSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextFlowSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextFlowSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextFlowSource_)
                {
                  ::std::unique_ptr< NextFlowSource_type > r (
                    dynamic_cast< NextFlowSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextFlowSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // FlowSourceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "FlowSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< FlowSourceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->FlowSourceBaseline_)
                {
                  ::std::unique_ptr< FlowSourceBaseline_type > r (
                    dynamic_cast< FlowSourceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->FlowSourceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // PressureSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "PressureSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< PressureSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->PressureSource_)
                {
                  ::std::unique_ptr< PressureSource_type > r (
                    dynamic_cast< PressureSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->PressureSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextPressureSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextPressureSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextPressureSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextPressureSource_)
                {
                  ::std::unique_ptr< NextPressureSource_type > r (
                    dynamic_cast< NextPressureSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextPressureSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // PressureSourceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "PressureSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< PressureSourceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->PressureSourceBaseline_)
                {
                  ::std::unique_ptr< PressureSourceBaseline_type > r (
                    dynamic_cast< PressureSourceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->PressureSourceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ValveBreakdownPressure
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ValveBreakdownPressure",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ValveBreakdownPressure_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ValveBreakdownPressure_)
                {
                  ::std::unique_ptr< ValveBreakdownPressure_type > r (
                    dynamic_cast< ValveBreakdownPressure_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ValveBreakdownPressure_.set (::std::move (r));
                  continue;
                }
              }
            }

            break;
          }
        }

        FluidCircuitPathData* FluidCircuitPathData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class FluidCircuitPathData (*this, f, c);
        }

        FluidCircuitPathData& FluidCircuitPathData::
        operator= (const FluidCircuitPathData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::CircuitPathData& > (*this) = x;
            this->Resistance_ = x.Resistance_;
            this->NextResistance_ = x.NextResistance_;
            this->ResistanceBaseline_ = x.ResistanceBaseline_;
            this->CardiovascularRegion_ = x.CardiovascularRegion_;
            this->Compliance_ = x.Compliance_;
            this->NextCompliance_ = x.NextCompliance_;
            this->ComplianceBaseline_ = x.ComplianceBaseline_;
            this->Inertance_ = x.Inertance_;
            this->NextInertance_ = x.NextInertance_;
            this->InertanceBaseline_ = x.InertanceBaseline_;
            this->Flow_ = x.Flow_;
            this->NextFlow_ = x.NextFlow_;
            this->FlowSource_ = x.FlowSource_;
            this->NextFlowSource_ = x.NextFlowSource_;
            this->FlowSourceBaseline_ = x.FlowSourceBaseline_;
            this->PressureSource_ = x.PressureSource_;
            this->NextPressureSource_ = x.NextPressureSource_;
            this->PressureSourceBaseline_ = x.PressureSourceBaseline_;
            this->ValveBreakdownPressure_ = x.ValveBreakdownPressure_;
          }

          return *this;
        }

        FluidCircuitPathData::
        ~FluidCircuitPathData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, FluidCircuitPathData >
        _xsd_FluidCircuitPathData_type_factory_init (
          "FluidCircuitPathData",
          "uri:/mil/tatrc/physiology/datamodel");

        // ThermalCircuitData
        //

        ThermalCircuitData::
        ThermalCircuitData ()
        : ::mil::tatrc::physiology::datamodel::CircuitData (),
          Node_ (this),
          Path_ (this)
        {
        }

        ThermalCircuitData::
        ThermalCircuitData (const Name_type& Name)
        : ::mil::tatrc::physiology::datamodel::CircuitData (Name),
          Node_ (this),
          Path_ (this)
        {
        }

        ThermalCircuitData::
        ThermalCircuitData (::std::unique_ptr< Name_type > Name)
        : ::mil::tatrc::physiology::datamodel::CircuitData (std::move (Name)),
          Node_ (this),
          Path_ (this)
        {
        }

        ThermalCircuitData::
        ThermalCircuitData (const ThermalCircuitData& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitData (x, f, c),
          Node_ (x.Node_, f, this),
          Path_ (x.Path_, f, this)
        {
        }

        ThermalCircuitData::
        ThermalCircuitData (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitData (e, f | ::xml_schema::flags::base, c),
          Node_ (this),
          Path_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void ThermalCircuitData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::CircuitData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Node
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Node",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Node_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< Node_type > r (
                  dynamic_cast< Node_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->Node_.push_back (::std::move (r));
                continue;
              }
            }

            // Path
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Path",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Path_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< Path_type > r (
                  dynamic_cast< Path_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->Path_.push_back (::std::move (r));
                continue;
              }
            }

            break;
          }
        }

        ThermalCircuitData* ThermalCircuitData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class ThermalCircuitData (*this, f, c);
        }

        ThermalCircuitData& ThermalCircuitData::
        operator= (const ThermalCircuitData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::CircuitData& > (*this) = x;
            this->Node_ = x.Node_;
            this->Path_ = x.Path_;
          }

          return *this;
        }

        ThermalCircuitData::
        ~ThermalCircuitData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, ThermalCircuitData >
        _xsd_ThermalCircuitData_type_factory_init (
          "ThermalCircuitData",
          "uri:/mil/tatrc/physiology/datamodel");

        // ThermalCircuitNodeData
        //

        ThermalCircuitNodeData::
        ThermalCircuitNodeData ()
        : ::mil::tatrc::physiology::datamodel::CircuitNodeData (),
          Temperature_ (this),
          NextTemperature_ (this),
          Heat_ (this),
          NextHeat_ (this),
          HeatBaseline_ (this)
        {
        }

        ThermalCircuitNodeData::
        ThermalCircuitNodeData (const Name_type& Name)
        : ::mil::tatrc::physiology::datamodel::CircuitNodeData (Name),
          Temperature_ (this),
          NextTemperature_ (this),
          Heat_ (this),
          NextHeat_ (this),
          HeatBaseline_ (this)
        {
        }

        ThermalCircuitNodeData::
        ThermalCircuitNodeData (::std::unique_ptr< Name_type > Name)
        : ::mil::tatrc::physiology::datamodel::CircuitNodeData (std::move (Name)),
          Temperature_ (this),
          NextTemperature_ (this),
          Heat_ (this),
          NextHeat_ (this),
          HeatBaseline_ (this)
        {
        }

        ThermalCircuitNodeData::
        ThermalCircuitNodeData (const ThermalCircuitNodeData& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitNodeData (x, f, c),
          Temperature_ (x.Temperature_, f, this),
          NextTemperature_ (x.NextTemperature_, f, this),
          Heat_ (x.Heat_, f, this),
          NextHeat_ (x.NextHeat_, f, this),
          HeatBaseline_ (x.HeatBaseline_, f, this)
        {
        }

        ThermalCircuitNodeData::
        ThermalCircuitNodeData (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitNodeData (e, f | ::xml_schema::flags::base, c),
          Temperature_ (this),
          NextTemperature_ (this),
          Heat_ (this),
          NextHeat_ (this),
          HeatBaseline_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void ThermalCircuitNodeData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::CircuitNodeData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Temperature
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Temperature",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Temperature_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Temperature_)
                {
                  ::std::unique_ptr< Temperature_type > r (
                    dynamic_cast< Temperature_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Temperature_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextTemperature
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextTemperature",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextTemperature_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextTemperature_)
                {
                  ::std::unique_ptr< NextTemperature_type > r (
                    dynamic_cast< NextTemperature_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextTemperature_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Heat
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Heat",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Heat_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Heat_)
                {
                  ::std::unique_ptr< Heat_type > r (
                    dynamic_cast< Heat_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Heat_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextHeat
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextHeat",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextHeat_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextHeat_)
                {
                  ::std::unique_ptr< NextHeat_type > r (
                    dynamic_cast< NextHeat_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextHeat_.set (::std::move (r));
                  continue;
                }
              }
            }

            // HeatBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "HeatBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< HeatBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->HeatBaseline_)
                {
                  ::std::unique_ptr< HeatBaseline_type > r (
                    dynamic_cast< HeatBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->HeatBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            break;
          }
        }

        ThermalCircuitNodeData* ThermalCircuitNodeData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class ThermalCircuitNodeData (*this, f, c);
        }

        ThermalCircuitNodeData& ThermalCircuitNodeData::
        operator= (const ThermalCircuitNodeData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::CircuitNodeData& > (*this) = x;
            this->Temperature_ = x.Temperature_;
            this->NextTemperature_ = x.NextTemperature_;
            this->Heat_ = x.Heat_;
            this->NextHeat_ = x.NextHeat_;
            this->HeatBaseline_ = x.HeatBaseline_;
          }

          return *this;
        }

        ThermalCircuitNodeData::
        ~ThermalCircuitNodeData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, ThermalCircuitNodeData >
        _xsd_ThermalCircuitNodeData_type_factory_init (
          "ThermalCircuitNodeData",
          "uri:/mil/tatrc/physiology/datamodel");

        // ThermalCircuitPathData
        //

        ThermalCircuitPathData::
        ThermalCircuitPathData ()
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Capacitance_ (this),
          NextCapacitance_ (this),
          CapacitanceBaseline_ (this),
          Inductance_ (this),
          NextInductance_ (this),
          InductanceBaseline_ (this),
          HeatTransferRate_ (this),
          NextHeatTransferRate_ (this),
          HeatSource_ (this),
          NextHeatSource_ (this),
          HeatSourceBaseline_ (this),
          TemperatureSource_ (this),
          NextTemperatureSource_ (this),
          TemperatureSourceBaseline_ (this),
          ValveBreakdownTemperature_ (this)
        {
        }

        ThermalCircuitPathData::
        ThermalCircuitPathData (const Name_type& Name,
                                const SourceNode_type& SourceNode,
                                const TargetNode_type& TargetNode)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (Name,
                                                                SourceNode,
                                                                TargetNode),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Capacitance_ (this),
          NextCapacitance_ (this),
          CapacitanceBaseline_ (this),
          Inductance_ (this),
          NextInductance_ (this),
          InductanceBaseline_ (this),
          HeatTransferRate_ (this),
          NextHeatTransferRate_ (this),
          HeatSource_ (this),
          NextHeatSource_ (this),
          HeatSourceBaseline_ (this),
          TemperatureSource_ (this),
          NextTemperatureSource_ (this),
          TemperatureSourceBaseline_ (this),
          ValveBreakdownTemperature_ (this)
        {
        }

        ThermalCircuitPathData::
        ThermalCircuitPathData (::std::unique_ptr< Name_type > Name,
                                ::std::unique_ptr< SourceNode_type > SourceNode,
                                ::std::unique_ptr< TargetNode_type > TargetNode)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (std::move (Name),
                                                                std::move (SourceNode),
                                                                std::move (TargetNode)),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Capacitance_ (this),
          NextCapacitance_ (this),
          CapacitanceBaseline_ (this),
          Inductance_ (this),
          NextInductance_ (this),
          InductanceBaseline_ (this),
          HeatTransferRate_ (this),
          NextHeatTransferRate_ (this),
          HeatSource_ (this),
          NextHeatSource_ (this),
          HeatSourceBaseline_ (this),
          TemperatureSource_ (this),
          NextTemperatureSource_ (this),
          TemperatureSourceBaseline_ (this),
          ValveBreakdownTemperature_ (this)
        {
        }

        ThermalCircuitPathData::
        ThermalCircuitPathData (const ThermalCircuitPathData& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (x, f, c),
          Resistance_ (x.Resistance_, f, this),
          NextResistance_ (x.NextResistance_, f, this),
          ResistanceBaseline_ (x.ResistanceBaseline_, f, this),
          Capacitance_ (x.Capacitance_, f, this),
          NextCapacitance_ (x.NextCapacitance_, f, this),
          CapacitanceBaseline_ (x.CapacitanceBaseline_, f, this),
          Inductance_ (x.Inductance_, f, this),
          NextInductance_ (x.NextInductance_, f, this),
          InductanceBaseline_ (x.InductanceBaseline_, f, this),
          HeatTransferRate_ (x.HeatTransferRate_, f, this),
          NextHeatTransferRate_ (x.NextHeatTransferRate_, f, this),
          HeatSource_ (x.HeatSource_, f, this),
          NextHeatSource_ (x.NextHeatSource_, f, this),
          HeatSourceBaseline_ (x.HeatSourceBaseline_, f, this),
          TemperatureSource_ (x.TemperatureSource_, f, this),
          NextTemperatureSource_ (x.NextTemperatureSource_, f, this),
          TemperatureSourceBaseline_ (x.TemperatureSourceBaseline_, f, this),
          ValveBreakdownTemperature_ (x.ValveBreakdownTemperature_, f, this)
        {
        }

        ThermalCircuitPathData::
        ThermalCircuitPathData (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::CircuitPathData (e, f | ::xml_schema::flags::base, c),
          Resistance_ (this),
          NextResistance_ (this),
          ResistanceBaseline_ (this),
          Capacitance_ (this),
          NextCapacitance_ (this),
          CapacitanceBaseline_ (this),
          Inductance_ (this),
          NextInductance_ (this),
          InductanceBaseline_ (this),
          HeatTransferRate_ (this),
          NextHeatTransferRate_ (this),
          HeatSource_ (this),
          NextHeatSource_ (this),
          HeatSourceBaseline_ (this),
          TemperatureSource_ (this),
          NextTemperatureSource_ (this),
          TemperatureSourceBaseline_ (this),
          ValveBreakdownTemperature_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void ThermalCircuitPathData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::CircuitPathData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Resistance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Resistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Resistance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Resistance_)
                {
                  ::std::unique_ptr< Resistance_type > r (
                    dynamic_cast< Resistance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Resistance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextResistance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextResistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextResistance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextResistance_)
                {
                  ::std::unique_ptr< NextResistance_type > r (
                    dynamic_cast< NextResistance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextResistance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ResistanceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ResistanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ResistanceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ResistanceBaseline_)
                {
                  ::std::unique_ptr< ResistanceBaseline_type > r (
                    dynamic_cast< ResistanceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ResistanceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Capacitance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Capacitance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Capacitance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Capacitance_)
                {
                  ::std::unique_ptr< Capacitance_type > r (
                    dynamic_cast< Capacitance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Capacitance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextCapacitance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextCapacitance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextCapacitance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextCapacitance_)
                {
                  ::std::unique_ptr< NextCapacitance_type > r (
                    dynamic_cast< NextCapacitance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextCapacitance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // CapacitanceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "CapacitanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< CapacitanceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->CapacitanceBaseline_)
                {
                  ::std::unique_ptr< CapacitanceBaseline_type > r (
                    dynamic_cast< CapacitanceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->CapacitanceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Inductance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Inductance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Inductance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Inductance_)
                {
                  ::std::unique_ptr< Inductance_type > r (
                    dynamic_cast< Inductance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Inductance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextInductance
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextInductance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextInductance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextInductance_)
                {
                  ::std::unique_ptr< NextInductance_type > r (
                    dynamic_cast< NextInductance_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextInductance_.set (::std::move (r));
                  continue;
                }
              }
            }

            // InductanceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "InductanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< InductanceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->InductanceBaseline_)
                {
                  ::std::unique_ptr< InductanceBaseline_type > r (
                    dynamic_cast< InductanceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->InductanceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // HeatTransferRate
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "HeatTransferRate",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< HeatTransferRate_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->HeatTransferRate_)
                {
                  ::std::unique_ptr< HeatTransferRate_type > r (
                    dynamic_cast< HeatTransferRate_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->HeatTransferRate_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextHeatTransferRate
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextHeatTransferRate",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextHeatTransferRate_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextHeatTransferRate_)
                {
                  ::std::unique_ptr< NextHeatTransferRate_type > r (
                    dynamic_cast< NextHeatTransferRate_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextHeatTransferRate_.set (::std::move (r));
                  continue;
                }
              }
            }

            // HeatSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "HeatSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< HeatSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->HeatSource_)
                {
                  ::std::unique_ptr< HeatSource_type > r (
                    dynamic_cast< HeatSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->HeatSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextHeatSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextHeatSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextHeatSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextHeatSource_)
                {
                  ::std::unique_ptr< NextHeatSource_type > r (
                    dynamic_cast< NextHeatSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextHeatSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // HeatSourceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "HeatSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< HeatSourceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->HeatSourceBaseline_)
                {
                  ::std::unique_ptr< HeatSourceBaseline_type > r (
                    dynamic_cast< HeatSourceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->HeatSourceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // TemperatureSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "TemperatureSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< TemperatureSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->TemperatureSource_)
                {
                  ::std::unique_ptr< TemperatureSource_type > r (
                    dynamic_cast< TemperatureSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->TemperatureSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // NextTemperatureSource
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "NextTemperatureSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< NextTemperatureSource_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->NextTemperatureSource_)
                {
                  ::std::unique_ptr< NextTemperatureSource_type > r (
                    dynamic_cast< NextTemperatureSource_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->NextTemperatureSource_.set (::std::move (r));
                  continue;
                }
              }
            }

            // TemperatureSourceBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "TemperatureSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< TemperatureSourceBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->TemperatureSourceBaseline_)
                {
                  ::std::unique_ptr< TemperatureSourceBaseline_type > r (
                    dynamic_cast< TemperatureSourceBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->TemperatureSourceBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ValveBreakdownTemperature
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ValveBreakdownTemperature",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ValveBreakdownTemperature_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ValveBreakdownTemperature_)
                {
                  ::std::unique_ptr< ValveBreakdownTemperature_type > r (
                    dynamic_cast< ValveBreakdownTemperature_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ValveBreakdownTemperature_.set (::std::move (r));
                  continue;
                }
              }
            }

            break;
          }
        }

        ThermalCircuitPathData* ThermalCircuitPathData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class ThermalCircuitPathData (*this, f, c);
        }

        ThermalCircuitPathData& ThermalCircuitPathData::
        operator= (const ThermalCircuitPathData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::CircuitPathData& > (*this) = x;
            this->Resistance_ = x.Resistance_;
            this->NextResistance_ = x.NextResistance_;
            this->ResistanceBaseline_ = x.ResistanceBaseline_;
            this->Capacitance_ = x.Capacitance_;
            this->NextCapacitance_ = x.NextCapacitance_;
            this->CapacitanceBaseline_ = x.CapacitanceBaseline_;
            this->Inductance_ = x.Inductance_;
            this->NextInductance_ = x.NextInductance_;
            this->InductanceBaseline_ = x.InductanceBaseline_;
            this->HeatTransferRate_ = x.HeatTransferRate_;
            this->NextHeatTransferRate_ = x.NextHeatTransferRate_;
            this->HeatSource_ = x.HeatSource_;
            this->NextHeatSource_ = x.NextHeatSource_;
            this->HeatSourceBaseline_ = x.HeatSourceBaseline_;
            this->TemperatureSource_ = x.TemperatureSource_;
            this->NextTemperatureSource_ = x.NextTemperatureSource_;
            this->TemperatureSourceBaseline_ = x.TemperatureSourceBaseline_;
            this->ValveBreakdownTemperature_ = x.ValveBreakdownTemperature_;
          }

          return *this;
        }

        ThermalCircuitPathData::
        ~ThermalCircuitPathData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, ThermalCircuitPathData >
        _xsd_ThermalCircuitPathData_type_factory_init (
          "ThermalCircuitPathData",
          "uri:/mil/tatrc/physiology/datamodel");

        // CircuitManagerData
        //

        CircuitManagerData::
        CircuitManagerData ()
        : ::mil::tatrc::physiology::datamodel::ObjectData (),
          ElectricalNode_ (this),
          ElectricalPath_ (this),
          ElectricalCircuit_ (this),
          FluidNode_ (this),
          FluidPath_ (this),
          FluidCircuit_ (this),
          ThermalNode_ (this),
          ThermalPath_ (this),
          ThermalCircuit_ (this)
        {
        }

        CircuitManagerData::
        CircuitManagerData (const CircuitManagerData& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::ObjectData (x, f, c),
          ElectricalNode_ (x.ElectricalNode_, f, this),
          ElectricalPath_ (x.ElectricalPath_, f, this),
          ElectricalCircuit_ (x.ElectricalCircuit_, f, this),
          FluidNode_ (x.FluidNode_, f, this),
          FluidPath_ (x.FluidPath_, f, this),
          FluidCircuit_ (x.FluidCircuit_, f, this),
          ThermalNode_ (x.ThermalNode_, f, this),
          ThermalPath_ (x.ThermalPath_, f, this),
          ThermalCircuit_ (x.ThermalCircuit_, f, this)
        {
        }

        CircuitManagerData::
        CircuitManagerData (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::ObjectData (e, f | ::xml_schema::flags::base, c),
          ElectricalNode_ (this),
          ElectricalPath_ (this),
          ElectricalCircuit_ (this),
          FluidNode_ (this),
          FluidPath_ (this),
          FluidCircuit_ (this),
          ThermalNode_ (this),
          ThermalPath_ (this),
          ThermalCircuit_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void CircuitManagerData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::ObjectData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // ElectricalNode
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ElectricalNode",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ElectricalNode_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< ElectricalNode_type > r (
                  dynamic_cast< ElectricalNode_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->ElectricalNode_.push_back (::std::move (r));
                continue;
              }
            }

            // ElectricalPath
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ElectricalPath",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ElectricalPath_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< ElectricalPath_type > r (
                  dynamic_cast< ElectricalPath_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->ElectricalPath_.push_back (::std::move (r));
                continue;
              }
            }

            // ElectricalCircuit
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ElectricalCircuit",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ElectricalCircuit_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< ElectricalCircuit_type > r (
                  dynamic_cast< ElectricalCircuit_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->ElectricalCircuit_.push_back (::std::move (r));
                continue;
              }
            }

            // FluidNode
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "FluidNode",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< FluidNode_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< FluidNode_type > r (
                  dynamic_cast< FluidNode_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->FluidNode_.push_back (::std::move (r));
                continue;
              }
            }

            // FluidPath
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "FluidPath",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< FluidPath_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< FluidPath_type > r (
                  dynamic_cast< FluidPath_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->FluidPath_.push_back (::std::move (r));
                continue;
              }
            }

            // FluidCircuit
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "FluidCircuit",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< FluidCircuit_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< FluidCircuit_type > r (
                  dynamic_cast< FluidCircuit_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->FluidCircuit_.push_back (::std::move (r));
                continue;
              }
            }

            // ThermalNode
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ThermalNode",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ThermalNode_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< ThermalNode_type > r (
                  dynamic_cast< ThermalNode_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->ThermalNode_.push_back (::std::move (r));
                continue;
              }
            }

            // ThermalPath
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ThermalPath",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ThermalPath_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< ThermalPath_type > r (
                  dynamic_cast< ThermalPath_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->ThermalPath_.push_back (::std::move (r));
                continue;
              }
            }

            // ThermalCircuit
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ThermalCircuit",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ThermalCircuit_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< ThermalCircuit_type > r (
                  dynamic_cast< ThermalCircuit_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->ThermalCircuit_.push_back (::std::move (r));
                continue;
              }
            }

            break;
          }
        }

        CircuitManagerData* CircuitManagerData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class CircuitManagerData (*this, f, c);
        }

        CircuitManagerData& CircuitManagerData::
        operator= (const CircuitManagerData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::ObjectData& > (*this) = x;
            this->ElectricalNode_ = x.ElectricalNode_;
            this->ElectricalPath_ = x.ElectricalPath_;
            this->ElectricalCircuit_ = x.ElectricalCircuit_;
            this->FluidNode_ = x.FluidNode_;
            this->FluidPath_ = x.FluidPath_;
            this->FluidCircuit_ = x.FluidCircuit_;
            this->ThermalNode_ = x.ThermalNode_;
            this->ThermalPath_ = x.ThermalPath_;
            this->ThermalCircuit_ = x.ThermalCircuit_;
          }

          return *this;
        }

        CircuitManagerData::
        ~CircuitManagerData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, CircuitManagerData >
        _xsd_CircuitManagerData_type_factory_init (
          "CircuitManagerData",
          "uri:/mil/tatrc/physiology/datamodel");
      }
    }
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        ::std::ostream&
        operator<< (::std::ostream& o, enumCircuitType::value i)
        {
          return o << enumCircuitType::_xsd_enumCircuitType_literals_[i];
        }

        ::std::ostream&
        operator<< (::std::ostream& o, const enumCircuitType& i)
        {
          return o << static_cast< const ::xml_schema::string& > (i);
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, enumCircuitType >
        _xsd_enumCircuitType_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, enumResistancePathType::value i)
        {
          return o << enumResistancePathType::_xsd_enumResistancePathType_literals_[i];
        }

        ::std::ostream&
        operator<< (::std::ostream& o, const enumResistancePathType& i)
        {
          return o << static_cast< const ::xml_schema::string& > (i);
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, enumResistancePathType >
        _xsd_enumResistancePathType_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, const CircuitData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::ObjectData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            o << ::std::endl << "Name: ";
            om.insert (o, i.Name ());
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (CircuitData::ReferenceNode_const_iterator
                 b (i.ReferenceNode ().begin ()), e (i.ReferenceNode ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "ReferenceNode: ";
              om.insert (o, *b);
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CircuitData >
        _xsd_CircuitData_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, const CircuitNodeData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::ObjectData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            o << ::std::endl << "Name: ";
            om.insert (o, i.Name ());
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CircuitNodeData >
        _xsd_CircuitNodeData_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, const CircuitPathData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::ObjectData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            o << ::std::endl << "Name: ";
            om.insert (o, i.Name ());
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            o << ::std::endl << "SourceNode: ";
            om.insert (o, i.SourceNode ());
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            o << ::std::endl << "TargetNode: ";
            om.insert (o, i.TargetNode ());
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Switch ())
            {
              o << ::std::endl << "Switch: ";
              om.insert (o, *i.Switch ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextSwitch ())
            {
              o << ::std::endl << "NextSwitch: ";
              om.insert (o, *i.NextSwitch ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Valve ())
            {
              o << ::std::endl << "Valve: ";
              om.insert (o, *i.Valve ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextValve ())
            {
              o << ::std::endl << "NextValve: ";
              om.insert (o, *i.NextValve ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.PolarizedState ())
            {
              o << ::std::endl << "PolarizedState: ";
              om.insert (o, *i.PolarizedState ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextPolarizedState ())
            {
              o << ::std::endl << "NextPolarizedState: ";
              om.insert (o, *i.NextPolarizedState ());
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CircuitPathData >
        _xsd_CircuitPathData_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, const ElectricalCircuitData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (ElectricalCircuitData::Node_const_iterator
                 b (i.Node ().begin ()), e (i.Node ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "Node: ";
              om.insert (o, *b);
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (ElectricalCircuitData::Path_const_iterator
                 b (i.Path ().begin ()), e (i.Path ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "Path: ";
              om.insert (o, *b);
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ElectricalCircuitData >
        _xsd_ElectricalCircuitData_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, const ElectricalCircuitNodeData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitNodeData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Voltage ())
            {
              o << ::std::endl << "Voltage: ";
              om.insert (o, *i.Voltage ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextVoltage ())
            {
              o << ::std::endl << "NextVoltage: ";
              om.insert (o, *i.NextVoltage ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Charge ())
            {
              o << ::std::endl << "Charge: ";
              om.insert (o, *i.Charge ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextCharge ())
            {
              o << ::std::endl << "NextCharge: ";
              om.insert (o, *i.NextCharge ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ChargeBaseline ())
            {
              o << ::std::endl << "ChargeBaseline: ";
              om.insert (o, *i.ChargeBaseline ());
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ElectricalCircuitNodeData >
        _xsd_ElectricalCircuitNodeData_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, const ElectricalCircuitPathData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitPathData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Resistance ())
            {
              o << ::std::endl << "Resistance: ";
              om.insert (o, *i.Resistance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextResistance ())
            {
              o << ::std::endl << "NextResistance: ";
              om.insert (o, *i.NextResistance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ResistanceBaseline ())
            {
              o << ::std::endl << "ResistanceBaseline: ";
              om.insert (o, *i.ResistanceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Capacitance ())
            {
              o << ::std::endl << "Capacitance: ";
              om.insert (o, *i.Capacitance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextCapacitance ())
            {
              o << ::std::endl << "NextCapacitance: ";
              om.insert (o, *i.NextCapacitance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.CapacitanceBaseline ())
            {
              o << ::std::endl << "CapacitanceBaseline: ";
              om.insert (o, *i.CapacitanceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Inductance ())
            {
              o << ::std::endl << "Inductance: ";
              om.insert (o, *i.Inductance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextInductance ())
            {
              o << ::std::endl << "NextInductance: ";
              om.insert (o, *i.NextInductance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.InductanceBaseline ())
            {
              o << ::std::endl << "InductanceBaseline: ";
              om.insert (o, *i.InductanceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Current ())
            {
              o << ::std::endl << "Current: ";
              om.insert (o, *i.Current ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextCurrent ())
            {
              o << ::std::endl << "NextCurrent: ";
              om.insert (o, *i.NextCurrent ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.CurrentSource ())
            {
              o << ::std::endl << "CurrentSource: ";
              om.insert (o, *i.CurrentSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextCurrentSource ())
            {
              o << ::std::endl << "NextCurrentSource: ";
              om.insert (o, *i.NextCurrentSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.CurrentSourceBaseline ())
            {
              o << ::std::endl << "CurrentSourceBaseline: ";
              om.insert (o, *i.CurrentSourceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.VoltageSource ())
            {
              o << ::std::endl << "VoltageSource: ";
              om.insert (o, *i.VoltageSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextVoltageSource ())
            {
              o << ::std::endl << "NextVoltageSource: ";
              om.insert (o, *i.NextVoltageSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.VoltageSourceBaseline ())
            {
              o << ::std::endl << "VoltageSourceBaseline: ";
              om.insert (o, *i.VoltageSourceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ValveBreakdownVoltage ())
            {
              o << ::std::endl << "ValveBreakdownVoltage: ";
              om.insert (o, *i.ValveBreakdownVoltage ());
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ElectricalCircuitPathData >
        _xsd_ElectricalCircuitPathData_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, const FluidCircuitData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (FluidCircuitData::Node_const_iterator
                 b (i.Node ().begin ()), e (i.Node ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "Node: ";
              om.insert (o, *b);
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (FluidCircuitData::Path_const_iterator
                 b (i.Path ().begin ()), e (i.Path ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "Path: ";
              om.insert (o, *b);
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, FluidCircuitData >
        _xsd_FluidCircuitData_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, const FluidCircuitNodeData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitNodeData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Pressure ())
            {
              o << ::std::endl << "Pressure: ";
              om.insert (o, *i.Pressure ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextPressure ())
            {
              o << ::std::endl << "NextPressure: ";
              om.insert (o, *i.NextPressure ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Volume ())
            {
              o << ::std::endl << "Volume: ";
              om.insert (o, *i.Volume ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextVolume ())
            {
              o << ::std::endl << "NextVolume: ";
              om.insert (o, *i.NextVolume ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.VolumeBaseline ())
            {
              o << ::std::endl << "VolumeBaseline: ";
              om.insert (o, *i.VolumeBaseline ());
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, FluidCircuitNodeData >
        _xsd_FluidCircuitNodeData_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, const FluidCircuitPathData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitPathData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Resistance ())
            {
              o << ::std::endl << "Resistance: ";
              om.insert (o, *i.Resistance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextResistance ())
            {
              o << ::std::endl << "NextResistance: ";
              om.insert (o, *i.NextResistance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ResistanceBaseline ())
            {
              o << ::std::endl << "ResistanceBaseline: ";
              om.insert (o, *i.ResistanceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.CardiovascularRegion ())
            {
              o << ::std::endl << "CardiovascularRegion: ";
              om.insert (o, *i.CardiovascularRegion ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Compliance ())
            {
              o << ::std::endl << "Compliance: ";
              om.insert (o, *i.Compliance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextCompliance ())
            {
              o << ::std::endl << "NextCompliance: ";
              om.insert (o, *i.NextCompliance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ComplianceBaseline ())
            {
              o << ::std::endl << "ComplianceBaseline: ";
              om.insert (o, *i.ComplianceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Inertance ())
            {
              o << ::std::endl << "Inertance: ";
              om.insert (o, *i.Inertance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextInertance ())
            {
              o << ::std::endl << "NextInertance: ";
              om.insert (o, *i.NextInertance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.InertanceBaseline ())
            {
              o << ::std::endl << "InertanceBaseline: ";
              om.insert (o, *i.InertanceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Flow ())
            {
              o << ::std::endl << "Flow: ";
              om.insert (o, *i.Flow ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextFlow ())
            {
              o << ::std::endl << "NextFlow: ";
              om.insert (o, *i.NextFlow ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.FlowSource ())
            {
              o << ::std::endl << "FlowSource: ";
              om.insert (o, *i.FlowSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextFlowSource ())
            {
              o << ::std::endl << "NextFlowSource: ";
              om.insert (o, *i.NextFlowSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.FlowSourceBaseline ())
            {
              o << ::std::endl << "FlowSourceBaseline: ";
              om.insert (o, *i.FlowSourceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.PressureSource ())
            {
              o << ::std::endl << "PressureSource: ";
              om.insert (o, *i.PressureSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextPressureSource ())
            {
              o << ::std::endl << "NextPressureSource: ";
              om.insert (o, *i.NextPressureSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.PressureSourceBaseline ())
            {
              o << ::std::endl << "PressureSourceBaseline: ";
              om.insert (o, *i.PressureSourceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ValveBreakdownPressure ())
            {
              o << ::std::endl << "ValveBreakdownPressure: ";
              om.insert (o, *i.ValveBreakdownPressure ());
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, FluidCircuitPathData >
        _xsd_FluidCircuitPathData_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, const ThermalCircuitData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (ThermalCircuitData::Node_const_iterator
                 b (i.Node ().begin ()), e (i.Node ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "Node: ";
              om.insert (o, *b);
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (ThermalCircuitData::Path_const_iterator
                 b (i.Path ().begin ()), e (i.Path ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "Path: ";
              om.insert (o, *b);
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ThermalCircuitData >
        _xsd_ThermalCircuitData_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, const ThermalCircuitNodeData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitNodeData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Temperature ())
            {
              o << ::std::endl << "Temperature: ";
              om.insert (o, *i.Temperature ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextTemperature ())
            {
              o << ::std::endl << "NextTemperature: ";
              om.insert (o, *i.NextTemperature ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Heat ())
            {
              o << ::std::endl << "Heat: ";
              om.insert (o, *i.Heat ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextHeat ())
            {
              o << ::std::endl << "NextHeat: ";
              om.insert (o, *i.NextHeat ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.HeatBaseline ())
            {
              o << ::std::endl << "HeatBaseline: ";
              om.insert (o, *i.HeatBaseline ());
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ThermalCircuitNodeData >
        _xsd_ThermalCircuitNodeData_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, const ThermalCircuitPathData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitPathData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Resistance ())
            {
              o << ::std::endl << "Resistance: ";
              om.insert (o, *i.Resistance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextResistance ())
            {
              o << ::std::endl << "NextResistance: ";
              om.insert (o, *i.NextResistance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ResistanceBaseline ())
            {
              o << ::std::endl << "ResistanceBaseline: ";
              om.insert (o, *i.ResistanceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Capacitance ())
            {
              o << ::std::endl << "Capacitance: ";
              om.insert (o, *i.Capacitance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextCapacitance ())
            {
              o << ::std::endl << "NextCapacitance: ";
              om.insert (o, *i.NextCapacitance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.CapacitanceBaseline ())
            {
              o << ::std::endl << "CapacitanceBaseline: ";
              om.insert (o, *i.CapacitanceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Inductance ())
            {
              o << ::std::endl << "Inductance: ";
              om.insert (o, *i.Inductance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextInductance ())
            {
              o << ::std::endl << "NextInductance: ";
              om.insert (o, *i.NextInductance ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.InductanceBaseline ())
            {
              o << ::std::endl << "InductanceBaseline: ";
              om.insert (o, *i.InductanceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.HeatTransferRate ())
            {
              o << ::std::endl << "HeatTransferRate: ";
              om.insert (o, *i.HeatTransferRate ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextHeatTransferRate ())
            {
              o << ::std::endl << "NextHeatTransferRate: ";
              om.insert (o, *i.NextHeatTransferRate ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.HeatSource ())
            {
              o << ::std::endl << "HeatSource: ";
              om.insert (o, *i.HeatSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextHeatSource ())
            {
              o << ::std::endl << "NextHeatSource: ";
              om.insert (o, *i.NextHeatSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.HeatSourceBaseline ())
            {
              o << ::std::endl << "HeatSourceBaseline: ";
              om.insert (o, *i.HeatSourceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.TemperatureSource ())
            {
              o << ::std::endl << "TemperatureSource: ";
              om.insert (o, *i.TemperatureSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.NextTemperatureSource ())
            {
              o << ::std::endl << "NextTemperatureSource: ";
              om.insert (o, *i.NextTemperatureSource ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.TemperatureSourceBaseline ())
            {
              o << ::std::endl << "TemperatureSourceBaseline: ";
              om.insert (o, *i.TemperatureSourceBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ValveBreakdownTemperature ())
            {
              o << ::std::endl << "ValveBreakdownTemperature: ";
              om.insert (o, *i.ValveBreakdownTemperature ());
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ThermalCircuitPathData >
        _xsd_ThermalCircuitPathData_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, const CircuitManagerData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::ObjectData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (CircuitManagerData::ElectricalNode_const_iterator
                 b (i.ElectricalNode ().begin ()), e (i.ElectricalNode ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "ElectricalNode: ";
              om.insert (o, *b);
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (CircuitManagerData::ElectricalPath_const_iterator
                 b (i.ElectricalPath ().begin ()), e (i.ElectricalPath ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "ElectricalPath: ";
              om.insert (o, *b);
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (CircuitManagerData::ElectricalCircuit_const_iterator
                 b (i.ElectricalCircuit ().begin ()), e (i.ElectricalCircuit ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "ElectricalCircuit: ";
              om.insert (o, *b);
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (CircuitManagerData::FluidNode_const_iterator
                 b (i.FluidNode ().begin ()), e (i.FluidNode ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "FluidNode: ";
              om.insert (o, *b);
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (CircuitManagerData::FluidPath_const_iterator
                 b (i.FluidPath ().begin ()), e (i.FluidPath ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "FluidPath: ";
              om.insert (o, *b);
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (CircuitManagerData::FluidCircuit_const_iterator
                 b (i.FluidCircuit ().begin ()), e (i.FluidCircuit ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "FluidCircuit: ";
              om.insert (o, *b);
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (CircuitManagerData::ThermalNode_const_iterator
                 b (i.ThermalNode ().begin ()), e (i.ThermalNode ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "ThermalNode: ";
              om.insert (o, *b);
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (CircuitManagerData::ThermalPath_const_iterator
                 b (i.ThermalPath ().begin ()), e (i.ThermalPath ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "ThermalPath: ";
              om.insert (o, *b);
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (CircuitManagerData::ThermalCircuit_const_iterator
                 b (i.ThermalCircuit ().begin ()), e (i.ThermalCircuit ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "ThermalCircuit: ";
              om.insert (o, *b);
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CircuitManagerData >
        _xsd_CircuitManagerData_std_ostream_init;
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData >
        CircuitManager (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0,
            (f & ::xml_schema::flags::keep_dom) == 0);

          ::xsd::cxx::tree::error_handler< char > h;

          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::xsd::cxx::xml::dom::parse< char > (
              u, h, p, f));

          h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

          return ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData > (
            ::mil::tatrc::physiology::datamodel::CircuitManager (
              std::move (d), f | ::xml_schema::flags::own_dom, p));
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData >
        CircuitManager (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0,
            (f & ::xml_schema::flags::keep_dom) == 0);

          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::xsd::cxx::xml::dom::parse< char > (
              u, h, p, f));

          if (!d.get ())
            throw ::xsd::cxx::tree::parsing< char > ();

          return ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData > (
            ::mil::tatrc::physiology::datamodel::CircuitManager (
              std::move (d), f | ::xml_schema::flags::own_dom, p));
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData >
        CircuitManager (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::xsd::cxx::xml::dom::parse< char > (
              u, h, p, f));

          if (!d.get ())
            throw ::xsd::cxx::tree::parsing< char > ();

          return ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData > (
            ::mil::tatrc::physiology::datamodel::CircuitManager (
              std::move (d), f | ::xml_schema::flags::own_dom, p));
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData >
        CircuitManager (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0,
            (f & ::xml_schema::flags::keep_dom) == 0);

          ::xsd::cxx::xml::sax::std_input_source isrc (is);
          return ::mil::tatrc::physiology::datamodel::CircuitManager (isrc, f, p);
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData >
        CircuitManager (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0,
            (f & ::xml_schema::flags::keep_dom) == 0);

          ::xsd::cxx::xml::sax::std_input_source isrc (is);
          return ::mil::tatrc::physiology::datamodel::CircuitManager (isrc, h, f, p);
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData >
        CircuitManager (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::sax::std_input_source isrc (is);
          return ::mil::tatrc::physiology::datamodel::CircuitManager (isrc, h, f, p);
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData >
        CircuitManager (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0,
            (f & ::xml_schema::flags::keep_dom) == 0);

          ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
          return ::mil::tatrc::physiology::datamodel::CircuitManager (isrc, f, p);
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData >
        CircuitManager (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0,
            (f & ::xml_schema::flags::keep_dom) == 0);

          ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
          return ::mil::tatrc::physiology::datamodel::CircuitManager (isrc, h, f, p);
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData >
        CircuitManager (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
          return ::mil::tatrc::physiology::datamodel::CircuitManager (isrc, h, f, p);
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData >
        CircuitManager (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
        {
          ::xsd::cxx::tree::error_handler< char > h;

          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::xsd::cxx::xml::dom::parse< char > (
              i, h, p, f));

          h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

          return ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData > (
            ::mil::tatrc::physiology::datamodel::CircuitManager (
              std::move (d), f | ::xml_schema::flags::own_dom, p));
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData >
        CircuitManager (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::xsd::cxx::xml::dom::parse< char > (
              i, h, p, f));

          if (!d.get ())
            throw ::xsd::cxx::tree::parsing< char > ();

          return ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData > (
            ::mil::tatrc::physiology::datamodel::CircuitManager (
              std::move (d), f | ::xml_schema::flags::own_dom, p));
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData >
        CircuitManager (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::xsd::cxx::xml::dom::parse< char > (
              i, h, p, f));

          if (!d.get ())
            throw ::xsd::cxx::tree::parsing< char > ();

          return ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData > (
            ::mil::tatrc::physiology::datamodel::CircuitManager (
              std::move (d), f | ::xml_schema::flags::own_dom, p));
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData >
        CircuitManager (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
        {
          if (f & ::xml_schema::flags::keep_dom)
          {
            ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
              static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

            return ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData > (
              ::mil::tatrc::physiology::datamodel::CircuitManager (
                std::move (d), f | ::xml_schema::flags::own_dom, p));
          }

          const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (e));

          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "CircuitManager",
              "uri:/mil/tatrc/physiology/datamodel",
              &::xsd::cxx::tree::factory_impl< ::mil::tatrc::physiology::datamodel::CircuitManagerData >,
              true, true, e, n, f, 0));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData > r (
              dynamic_cast< ::mil::tatrc::physiology::datamodel::CircuitManagerData* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            return r;
          }

          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "CircuitManager",
            "uri:/mil/tatrc/physiology/datamodel");
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData >
        CircuitManager (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
            ((f & ::xml_schema::flags::keep_dom) &&
             !(f & ::xml_schema::flags::own_dom))
            ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
            : 0);

          ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
          const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (e));

          if (f & ::xml_schema::flags::keep_dom)
            doc.setUserData (::xml_schema::dom::tree_node_key,
                             (c.get () ? &c : &d),
                             0);

          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "CircuitManager",
              "uri:/mil/tatrc/physiology/datamodel",
              &::xsd::cxx::tree::factory_impl< ::mil::tatrc::physiology::datamodel::CircuitManagerData >,
              true, true, e, n, f, 0));

          if (tmp.get () != 0)
          {

            ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::CircuitManagerData > r (
              dynamic_cast< ::mil::tatrc::physiology::datamodel::CircuitManagerData* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            return r;
          }

          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "CircuitManager",
            "uri:/mil/tatrc/physiology/datamodel");
        }
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        void
        operator<< (::xercesc::DOMElement& e, const enumCircuitType& i)
        {
          e << static_cast< const ::xml_schema::string& > (i);
        }

        void
        operator<< (::xercesc::DOMAttr& a, const enumCircuitType& i)
        {
          a << static_cast< const ::xml_schema::string& > (i);
        }

        void
        operator<< (::xml_schema::list_stream& l,
                    const enumCircuitType& i)
        {
          l << static_cast< const ::xml_schema::string& > (i);
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, enumCircuitType >
        _xsd_enumCircuitType_type_serializer_init (
          "enumCircuitType",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const enumResistancePathType& i)
        {
          e << static_cast< const ::xml_schema::string& > (i);
        }

        void
        operator<< (::xercesc::DOMAttr& a, const enumResistancePathType& i)
        {
          a << static_cast< const ::xml_schema::string& > (i);
        }

        void
        operator<< (::xml_schema::list_stream& l,
                    const enumResistancePathType& i)
        {
          l << static_cast< const ::xml_schema::string& > (i);
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, enumResistancePathType >
        _xsd_enumResistancePathType_type_serializer_init (
          "enumResistancePathType",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const CircuitData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::ObjectData& > (i);

          // Name
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            const CircuitData::Name_type& x (i.Name ());
            if (typeid (CircuitData::Name_type) == typeid (x))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "Name",
                  "uri:/mil/tatrc/physiology/datamodel",
                  e));

              s << x;
            }
            else
              tsm.serialize (
                "Name",
                "uri:/mil/tatrc/physiology/datamodel",
                false, true, e, x);
          }

          // ReferenceNode
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (CircuitData::ReferenceNode_const_iterator
                 b (i.ReferenceNode ().begin ()), n (i.ReferenceNode ().end ());
                 b != n; ++b)
            {
              if (typeid (CircuitData::ReferenceNode_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ReferenceNode",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "ReferenceNode",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CircuitData >
        _xsd_CircuitData_type_serializer_init (
          "CircuitData",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const CircuitNodeData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::ObjectData& > (i);

          // Name
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            const CircuitNodeData::Name_type& x (i.Name ());
            if (typeid (CircuitNodeData::Name_type) == typeid (x))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "Name",
                  "uri:/mil/tatrc/physiology/datamodel",
                  e));

              s << x;
            }
            else
              tsm.serialize (
                "Name",
                "uri:/mil/tatrc/physiology/datamodel",
                false, true, e, x);
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CircuitNodeData >
        _xsd_CircuitNodeData_type_serializer_init (
          "CircuitNodeData",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const CircuitPathData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::ObjectData& > (i);

          // Name
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            const CircuitPathData::Name_type& x (i.Name ());
            if (typeid (CircuitPathData::Name_type) == typeid (x))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "Name",
                  "uri:/mil/tatrc/physiology/datamodel",
                  e));

              s << x;
            }
            else
              tsm.serialize (
                "Name",
                "uri:/mil/tatrc/physiology/datamodel",
                false, true, e, x);
          }

          // SourceNode
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            const CircuitPathData::SourceNode_type& x (i.SourceNode ());
            if (typeid (CircuitPathData::SourceNode_type) == typeid (x))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "SourceNode",
                  "uri:/mil/tatrc/physiology/datamodel",
                  e));

              s << x;
            }
            else
              tsm.serialize (
                "SourceNode",
                "uri:/mil/tatrc/physiology/datamodel",
                false, true, e, x);
          }

          // TargetNode
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            const CircuitPathData::TargetNode_type& x (i.TargetNode ());
            if (typeid (CircuitPathData::TargetNode_type) == typeid (x))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "TargetNode",
                  "uri:/mil/tatrc/physiology/datamodel",
                  e));

              s << x;
            }
            else
              tsm.serialize (
                "TargetNode",
                "uri:/mil/tatrc/physiology/datamodel",
                false, true, e, x);
          }

          // Switch
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Switch ())
            {
              const CircuitPathData::Switch_type& x (*i.Switch ());
              if (typeid (CircuitPathData::Switch_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Switch",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Switch",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextSwitch
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextSwitch ())
            {
              const CircuitPathData::NextSwitch_type& x (*i.NextSwitch ());
              if (typeid (CircuitPathData::NextSwitch_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextSwitch",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextSwitch",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Valve
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Valve ())
            {
              const CircuitPathData::Valve_type& x (*i.Valve ());
              if (typeid (CircuitPathData::Valve_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Valve",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Valve",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextValve
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextValve ())
            {
              const CircuitPathData::NextValve_type& x (*i.NextValve ());
              if (typeid (CircuitPathData::NextValve_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextValve",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextValve",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // PolarizedState
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.PolarizedState ())
            {
              const CircuitPathData::PolarizedState_type& x (*i.PolarizedState ());
              if (typeid (CircuitPathData::PolarizedState_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "PolarizedState",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "PolarizedState",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextPolarizedState
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextPolarizedState ())
            {
              const CircuitPathData::NextPolarizedState_type& x (*i.NextPolarizedState ());
              if (typeid (CircuitPathData::NextPolarizedState_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextPolarizedState",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextPolarizedState",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CircuitPathData >
        _xsd_CircuitPathData_type_serializer_init (
          "CircuitPathData",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const ElectricalCircuitData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitData& > (i);

          // Node
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (ElectricalCircuitData::Node_const_iterator
                 b (i.Node ().begin ()), n (i.Node ().end ());
                 b != n; ++b)
            {
              if (typeid (ElectricalCircuitData::Node_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Node",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "Node",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }

          // Path
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (ElectricalCircuitData::Path_const_iterator
                 b (i.Path ().begin ()), n (i.Path ().end ());
                 b != n; ++b)
            {
              if (typeid (ElectricalCircuitData::Path_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Path",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "Path",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ElectricalCircuitData >
        _xsd_ElectricalCircuitData_type_serializer_init (
          "ElectricalCircuitData",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const ElectricalCircuitNodeData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitNodeData& > (i);

          // Voltage
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Voltage ())
            {
              const ElectricalCircuitNodeData::Voltage_type& x (*i.Voltage ());
              if (typeid (ElectricalCircuitNodeData::Voltage_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Voltage",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Voltage",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextVoltage
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextVoltage ())
            {
              const ElectricalCircuitNodeData::NextVoltage_type& x (*i.NextVoltage ());
              if (typeid (ElectricalCircuitNodeData::NextVoltage_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextVoltage",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextVoltage",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Charge
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Charge ())
            {
              const ElectricalCircuitNodeData::Charge_type& x (*i.Charge ());
              if (typeid (ElectricalCircuitNodeData::Charge_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Charge",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Charge",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextCharge
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextCharge ())
            {
              const ElectricalCircuitNodeData::NextCharge_type& x (*i.NextCharge ());
              if (typeid (ElectricalCircuitNodeData::NextCharge_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextCharge",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextCharge",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ChargeBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ChargeBaseline ())
            {
              const ElectricalCircuitNodeData::ChargeBaseline_type& x (*i.ChargeBaseline ());
              if (typeid (ElectricalCircuitNodeData::ChargeBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ChargeBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ChargeBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ElectricalCircuitNodeData >
        _xsd_ElectricalCircuitNodeData_type_serializer_init (
          "ElectricalCircuitNodeData",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const ElectricalCircuitPathData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitPathData& > (i);

          // Resistance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Resistance ())
            {
              const ElectricalCircuitPathData::Resistance_type& x (*i.Resistance ());
              if (typeid (ElectricalCircuitPathData::Resistance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Resistance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Resistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextResistance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextResistance ())
            {
              const ElectricalCircuitPathData::NextResistance_type& x (*i.NextResistance ());
              if (typeid (ElectricalCircuitPathData::NextResistance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextResistance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextResistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ResistanceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ResistanceBaseline ())
            {
              const ElectricalCircuitPathData::ResistanceBaseline_type& x (*i.ResistanceBaseline ());
              if (typeid (ElectricalCircuitPathData::ResistanceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ResistanceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ResistanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Capacitance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Capacitance ())
            {
              const ElectricalCircuitPathData::Capacitance_type& x (*i.Capacitance ());
              if (typeid (ElectricalCircuitPathData::Capacitance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Capacitance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Capacitance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextCapacitance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextCapacitance ())
            {
              const ElectricalCircuitPathData::NextCapacitance_type& x (*i.NextCapacitance ());
              if (typeid (ElectricalCircuitPathData::NextCapacitance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextCapacitance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextCapacitance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // CapacitanceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.CapacitanceBaseline ())
            {
              const ElectricalCircuitPathData::CapacitanceBaseline_type& x (*i.CapacitanceBaseline ());
              if (typeid (ElectricalCircuitPathData::CapacitanceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "CapacitanceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "CapacitanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Inductance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Inductance ())
            {
              const ElectricalCircuitPathData::Inductance_type& x (*i.Inductance ());
              if (typeid (ElectricalCircuitPathData::Inductance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Inductance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Inductance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextInductance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextInductance ())
            {
              const ElectricalCircuitPathData::NextInductance_type& x (*i.NextInductance ());
              if (typeid (ElectricalCircuitPathData::NextInductance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextInductance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextInductance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // InductanceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.InductanceBaseline ())
            {
              const ElectricalCircuitPathData::InductanceBaseline_type& x (*i.InductanceBaseline ());
              if (typeid (ElectricalCircuitPathData::InductanceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "InductanceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "InductanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Current
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Current ())
            {
              const ElectricalCircuitPathData::Current_type& x (*i.Current ());
              if (typeid (ElectricalCircuitPathData::Current_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Current",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Current",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextCurrent
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextCurrent ())
            {
              const ElectricalCircuitPathData::NextCurrent_type& x (*i.NextCurrent ());
              if (typeid (ElectricalCircuitPathData::NextCurrent_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextCurrent",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextCurrent",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // CurrentSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.CurrentSource ())
            {
              const ElectricalCircuitPathData::CurrentSource_type& x (*i.CurrentSource ());
              if (typeid (ElectricalCircuitPathData::CurrentSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "CurrentSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "CurrentSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextCurrentSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextCurrentSource ())
            {
              const ElectricalCircuitPathData::NextCurrentSource_type& x (*i.NextCurrentSource ());
              if (typeid (ElectricalCircuitPathData::NextCurrentSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextCurrentSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextCurrentSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // CurrentSourceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.CurrentSourceBaseline ())
            {
              const ElectricalCircuitPathData::CurrentSourceBaseline_type& x (*i.CurrentSourceBaseline ());
              if (typeid (ElectricalCircuitPathData::CurrentSourceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "CurrentSourceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "CurrentSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // VoltageSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.VoltageSource ())
            {
              const ElectricalCircuitPathData::VoltageSource_type& x (*i.VoltageSource ());
              if (typeid (ElectricalCircuitPathData::VoltageSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "VoltageSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "VoltageSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextVoltageSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextVoltageSource ())
            {
              const ElectricalCircuitPathData::NextVoltageSource_type& x (*i.NextVoltageSource ());
              if (typeid (ElectricalCircuitPathData::NextVoltageSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextVoltageSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextVoltageSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // VoltageSourceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.VoltageSourceBaseline ())
            {
              const ElectricalCircuitPathData::VoltageSourceBaseline_type& x (*i.VoltageSourceBaseline ());
              if (typeid (ElectricalCircuitPathData::VoltageSourceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "VoltageSourceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "VoltageSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ValveBreakdownVoltage
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ValveBreakdownVoltage ())
            {
              const ElectricalCircuitPathData::ValveBreakdownVoltage_type& x (*i.ValveBreakdownVoltage ());
              if (typeid (ElectricalCircuitPathData::ValveBreakdownVoltage_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ValveBreakdownVoltage",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ValveBreakdownVoltage",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ElectricalCircuitPathData >
        _xsd_ElectricalCircuitPathData_type_serializer_init (
          "ElectricalCircuitPathData",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const FluidCircuitData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitData& > (i);

          // Node
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (FluidCircuitData::Node_const_iterator
                 b (i.Node ().begin ()), n (i.Node ().end ());
                 b != n; ++b)
            {
              if (typeid (FluidCircuitData::Node_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Node",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "Node",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }

          // Path
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (FluidCircuitData::Path_const_iterator
                 b (i.Path ().begin ()), n (i.Path ().end ());
                 b != n; ++b)
            {
              if (typeid (FluidCircuitData::Path_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Path",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "Path",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FluidCircuitData >
        _xsd_FluidCircuitData_type_serializer_init (
          "FluidCircuitData",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const FluidCircuitNodeData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitNodeData& > (i);

          // Pressure
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Pressure ())
            {
              const FluidCircuitNodeData::Pressure_type& x (*i.Pressure ());
              if (typeid (FluidCircuitNodeData::Pressure_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Pressure",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Pressure",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextPressure
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextPressure ())
            {
              const FluidCircuitNodeData::NextPressure_type& x (*i.NextPressure ());
              if (typeid (FluidCircuitNodeData::NextPressure_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextPressure",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextPressure",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Volume
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Volume ())
            {
              const FluidCircuitNodeData::Volume_type& x (*i.Volume ());
              if (typeid (FluidCircuitNodeData::Volume_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Volume",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Volume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextVolume
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextVolume ())
            {
              const FluidCircuitNodeData::NextVolume_type& x (*i.NextVolume ());
              if (typeid (FluidCircuitNodeData::NextVolume_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextVolume",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // VolumeBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.VolumeBaseline ())
            {
              const FluidCircuitNodeData::VolumeBaseline_type& x (*i.VolumeBaseline ());
              if (typeid (FluidCircuitNodeData::VolumeBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "VolumeBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "VolumeBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FluidCircuitNodeData >
        _xsd_FluidCircuitNodeData_type_serializer_init (
          "FluidCircuitNodeData",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const FluidCircuitPathData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitPathData& > (i);

          // Resistance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Resistance ())
            {
              const FluidCircuitPathData::Resistance_type& x (*i.Resistance ());
              if (typeid (FluidCircuitPathData::Resistance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Resistance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Resistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextResistance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextResistance ())
            {
              const FluidCircuitPathData::NextResistance_type& x (*i.NextResistance ());
              if (typeid (FluidCircuitPathData::NextResistance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextResistance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextResistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ResistanceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ResistanceBaseline ())
            {
              const FluidCircuitPathData::ResistanceBaseline_type& x (*i.ResistanceBaseline ());
              if (typeid (FluidCircuitPathData::ResistanceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ResistanceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ResistanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // CardiovascularRegion
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.CardiovascularRegion ())
            {
              const FluidCircuitPathData::CardiovascularRegion_type& x (*i.CardiovascularRegion ());
              if (typeid (FluidCircuitPathData::CardiovascularRegion_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "CardiovascularRegion",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "CardiovascularRegion",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Compliance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Compliance ())
            {
              const FluidCircuitPathData::Compliance_type& x (*i.Compliance ());
              if (typeid (FluidCircuitPathData::Compliance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Compliance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Compliance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextCompliance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextCompliance ())
            {
              const FluidCircuitPathData::NextCompliance_type& x (*i.NextCompliance ());
              if (typeid (FluidCircuitPathData::NextCompliance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextCompliance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextCompliance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ComplianceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ComplianceBaseline ())
            {
              const FluidCircuitPathData::ComplianceBaseline_type& x (*i.ComplianceBaseline ());
              if (typeid (FluidCircuitPathData::ComplianceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ComplianceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ComplianceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Inertance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Inertance ())
            {
              const FluidCircuitPathData::Inertance_type& x (*i.Inertance ());
              if (typeid (FluidCircuitPathData::Inertance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Inertance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Inertance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextInertance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextInertance ())
            {
              const FluidCircuitPathData::NextInertance_type& x (*i.NextInertance ());
              if (typeid (FluidCircuitPathData::NextInertance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextInertance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextInertance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // InertanceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.InertanceBaseline ())
            {
              const FluidCircuitPathData::InertanceBaseline_type& x (*i.InertanceBaseline ());
              if (typeid (FluidCircuitPathData::InertanceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "InertanceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "InertanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Flow
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Flow ())
            {
              const FluidCircuitPathData::Flow_type& x (*i.Flow ());
              if (typeid (FluidCircuitPathData::Flow_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Flow",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Flow",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextFlow
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextFlow ())
            {
              const FluidCircuitPathData::NextFlow_type& x (*i.NextFlow ());
              if (typeid (FluidCircuitPathData::NextFlow_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextFlow",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextFlow",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // FlowSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.FlowSource ())
            {
              const FluidCircuitPathData::FlowSource_type& x (*i.FlowSource ());
              if (typeid (FluidCircuitPathData::FlowSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "FlowSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "FlowSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextFlowSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextFlowSource ())
            {
              const FluidCircuitPathData::NextFlowSource_type& x (*i.NextFlowSource ());
              if (typeid (FluidCircuitPathData::NextFlowSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextFlowSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextFlowSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // FlowSourceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.FlowSourceBaseline ())
            {
              const FluidCircuitPathData::FlowSourceBaseline_type& x (*i.FlowSourceBaseline ());
              if (typeid (FluidCircuitPathData::FlowSourceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "FlowSourceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "FlowSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // PressureSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.PressureSource ())
            {
              const FluidCircuitPathData::PressureSource_type& x (*i.PressureSource ());
              if (typeid (FluidCircuitPathData::PressureSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "PressureSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "PressureSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextPressureSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextPressureSource ())
            {
              const FluidCircuitPathData::NextPressureSource_type& x (*i.NextPressureSource ());
              if (typeid (FluidCircuitPathData::NextPressureSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextPressureSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextPressureSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // PressureSourceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.PressureSourceBaseline ())
            {
              const FluidCircuitPathData::PressureSourceBaseline_type& x (*i.PressureSourceBaseline ());
              if (typeid (FluidCircuitPathData::PressureSourceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "PressureSourceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "PressureSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ValveBreakdownPressure
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ValveBreakdownPressure ())
            {
              const FluidCircuitPathData::ValveBreakdownPressure_type& x (*i.ValveBreakdownPressure ());
              if (typeid (FluidCircuitPathData::ValveBreakdownPressure_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ValveBreakdownPressure",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ValveBreakdownPressure",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FluidCircuitPathData >
        _xsd_FluidCircuitPathData_type_serializer_init (
          "FluidCircuitPathData",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const ThermalCircuitData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitData& > (i);

          // Node
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (ThermalCircuitData::Node_const_iterator
                 b (i.Node ().begin ()), n (i.Node ().end ());
                 b != n; ++b)
            {
              if (typeid (ThermalCircuitData::Node_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Node",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "Node",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }

          // Path
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (ThermalCircuitData::Path_const_iterator
                 b (i.Path ().begin ()), n (i.Path ().end ());
                 b != n; ++b)
            {
              if (typeid (ThermalCircuitData::Path_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Path",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "Path",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ThermalCircuitData >
        _xsd_ThermalCircuitData_type_serializer_init (
          "ThermalCircuitData",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const ThermalCircuitNodeData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitNodeData& > (i);

          // Temperature
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Temperature ())
            {
              const ThermalCircuitNodeData::Temperature_type& x (*i.Temperature ());
              if (typeid (ThermalCircuitNodeData::Temperature_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Temperature",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Temperature",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextTemperature
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextTemperature ())
            {
              const ThermalCircuitNodeData::NextTemperature_type& x (*i.NextTemperature ());
              if (typeid (ThermalCircuitNodeData::NextTemperature_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextTemperature",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextTemperature",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Heat
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Heat ())
            {
              const ThermalCircuitNodeData::Heat_type& x (*i.Heat ());
              if (typeid (ThermalCircuitNodeData::Heat_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Heat",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Heat",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextHeat
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextHeat ())
            {
              const ThermalCircuitNodeData::NextHeat_type& x (*i.NextHeat ());
              if (typeid (ThermalCircuitNodeData::NextHeat_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextHeat",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextHeat",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // HeatBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.HeatBaseline ())
            {
              const ThermalCircuitNodeData::HeatBaseline_type& x (*i.HeatBaseline ());
              if (typeid (ThermalCircuitNodeData::HeatBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "HeatBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "HeatBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ThermalCircuitNodeData >
        _xsd_ThermalCircuitNodeData_type_serializer_init (
          "ThermalCircuitNodeData",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const ThermalCircuitPathData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::CircuitPathData& > (i);

          // Resistance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Resistance ())
            {
              const ThermalCircuitPathData::Resistance_type& x (*i.Resistance ());
              if (typeid (ThermalCircuitPathData::Resistance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Resistance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Resistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextResistance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextResistance ())
            {
              const ThermalCircuitPathData::NextResistance_type& x (*i.NextResistance ());
              if (typeid (ThermalCircuitPathData::NextResistance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextResistance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextResistance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ResistanceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ResistanceBaseline ())
            {
              const ThermalCircuitPathData::ResistanceBaseline_type& x (*i.ResistanceBaseline ());
              if (typeid (ThermalCircuitPathData::ResistanceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ResistanceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ResistanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Capacitance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Capacitance ())
            {
              const ThermalCircuitPathData::Capacitance_type& x (*i.Capacitance ());
              if (typeid (ThermalCircuitPathData::Capacitance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Capacitance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Capacitance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextCapacitance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextCapacitance ())
            {
              const ThermalCircuitPathData::NextCapacitance_type& x (*i.NextCapacitance ());
              if (typeid (ThermalCircuitPathData::NextCapacitance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextCapacitance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextCapacitance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // CapacitanceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.CapacitanceBaseline ())
            {
              const ThermalCircuitPathData::CapacitanceBaseline_type& x (*i.CapacitanceBaseline ());
              if (typeid (ThermalCircuitPathData::CapacitanceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "CapacitanceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "CapacitanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Inductance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Inductance ())
            {
              const ThermalCircuitPathData::Inductance_type& x (*i.Inductance ());
              if (typeid (ThermalCircuitPathData::Inductance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Inductance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Inductance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextInductance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextInductance ())
            {
              const ThermalCircuitPathData::NextInductance_type& x (*i.NextInductance ());
              if (typeid (ThermalCircuitPathData::NextInductance_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextInductance",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextInductance",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // InductanceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.InductanceBaseline ())
            {
              const ThermalCircuitPathData::InductanceBaseline_type& x (*i.InductanceBaseline ());
              if (typeid (ThermalCircuitPathData::InductanceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "InductanceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "InductanceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // HeatTransferRate
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.HeatTransferRate ())
            {
              const ThermalCircuitPathData::HeatTransferRate_type& x (*i.HeatTransferRate ());
              if (typeid (ThermalCircuitPathData::HeatTransferRate_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "HeatTransferRate",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "HeatTransferRate",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextHeatTransferRate
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextHeatTransferRate ())
            {
              const ThermalCircuitPathData::NextHeatTransferRate_type& x (*i.NextHeatTransferRate ());
              if (typeid (ThermalCircuitPathData::NextHeatTransferRate_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextHeatTransferRate",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextHeatTransferRate",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // HeatSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.HeatSource ())
            {
              const ThermalCircuitPathData::HeatSource_type& x (*i.HeatSource ());
              if (typeid (ThermalCircuitPathData::HeatSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "HeatSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "HeatSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextHeatSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextHeatSource ())
            {
              const ThermalCircuitPathData::NextHeatSource_type& x (*i.NextHeatSource ());
              if (typeid (ThermalCircuitPathData::NextHeatSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextHeatSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextHeatSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // HeatSourceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.HeatSourceBaseline ())
            {
              const ThermalCircuitPathData::HeatSourceBaseline_type& x (*i.HeatSourceBaseline ());
              if (typeid (ThermalCircuitPathData::HeatSourceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "HeatSourceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "HeatSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // TemperatureSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.TemperatureSource ())
            {
              const ThermalCircuitPathData::TemperatureSource_type& x (*i.TemperatureSource ());
              if (typeid (ThermalCircuitPathData::TemperatureSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "TemperatureSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "TemperatureSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // NextTemperatureSource
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.NextTemperatureSource ())
            {
              const ThermalCircuitPathData::NextTemperatureSource_type& x (*i.NextTemperatureSource ());
              if (typeid (ThermalCircuitPathData::NextTemperatureSource_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "NextTemperatureSource",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "NextTemperatureSource",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // TemperatureSourceBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.TemperatureSourceBaseline ())
            {
              const ThermalCircuitPathData::TemperatureSourceBaseline_type& x (*i.TemperatureSourceBaseline ());
              if (typeid (ThermalCircuitPathData::TemperatureSourceBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "TemperatureSourceBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "TemperatureSourceBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ValveBreakdownTemperature
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ValveBreakdownTemperature ())
            {
              const ThermalCircuitPathData::ValveBreakdownTemperature_type& x (*i.ValveBreakdownTemperature ());
              if (typeid (ThermalCircuitPathData::ValveBreakdownTemperature_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ValveBreakdownTemperature",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ValveBreakdownTemperature",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ThermalCircuitPathData >
        _xsd_ThermalCircuitPathData_type_serializer_init (
          "ThermalCircuitPathData",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const CircuitManagerData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::ObjectData& > (i);

          // ElectricalNode
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (CircuitManagerData::ElectricalNode_const_iterator
                 b (i.ElectricalNode ().begin ()), n (i.ElectricalNode ().end ());
                 b != n; ++b)
            {
              if (typeid (CircuitManagerData::ElectricalNode_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ElectricalNode",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "ElectricalNode",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }

          // ElectricalPath
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (CircuitManagerData::ElectricalPath_const_iterator
                 b (i.ElectricalPath ().begin ()), n (i.ElectricalPath ().end ());
                 b != n; ++b)
            {
              if (typeid (CircuitManagerData::ElectricalPath_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ElectricalPath",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "ElectricalPath",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }

          // ElectricalCircuit
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (CircuitManagerData::ElectricalCircuit_const_iterator
                 b (i.ElectricalCircuit ().begin ()), n (i.ElectricalCircuit ().end ());
                 b != n; ++b)
            {
              if (typeid (CircuitManagerData::ElectricalCircuit_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ElectricalCircuit",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "ElectricalCircuit",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }

          // FluidNode
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (CircuitManagerData::FluidNode_const_iterator
                 b (i.FluidNode ().begin ()), n (i.FluidNode ().end ());
                 b != n; ++b)
            {
              if (typeid (CircuitManagerData::FluidNode_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "FluidNode",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "FluidNode",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }

          // FluidPath
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (CircuitManagerData::FluidPath_const_iterator
                 b (i.FluidPath ().begin ()), n (i.FluidPath ().end ());
                 b != n; ++b)
            {
              if (typeid (CircuitManagerData::FluidPath_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "FluidPath",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "FluidPath",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }

          // FluidCircuit
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (CircuitManagerData::FluidCircuit_const_iterator
                 b (i.FluidCircuit ().begin ()), n (i.FluidCircuit ().end ());
                 b != n; ++b)
            {
              if (typeid (CircuitManagerData::FluidCircuit_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "FluidCircuit",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "FluidCircuit",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }

          // ThermalNode
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (CircuitManagerData::ThermalNode_const_iterator
                 b (i.ThermalNode ().begin ()), n (i.ThermalNode ().end ());
                 b != n; ++b)
            {
              if (typeid (CircuitManagerData::ThermalNode_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ThermalNode",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "ThermalNode",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }

          // ThermalPath
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (CircuitManagerData::ThermalPath_const_iterator
                 b (i.ThermalPath ().begin ()), n (i.ThermalPath ().end ());
                 b != n; ++b)
            {
              if (typeid (CircuitManagerData::ThermalPath_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ThermalPath",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "ThermalPath",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }

          // ThermalCircuit
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (CircuitManagerData::ThermalCircuit_const_iterator
                 b (i.ThermalCircuit ().begin ()), n (i.ThermalCircuit ().end ());
                 b != n; ++b)
            {
              if (typeid (CircuitManagerData::ThermalCircuit_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ThermalCircuit",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "ThermalCircuit",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CircuitManagerData >
        _xsd_CircuitManagerData_type_serializer_init (
          "CircuitManagerData",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        CircuitManager (::std::ostream& o,
                        const ::mil::tatrc::physiology::datamodel::CircuitManagerData& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0);

          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::mil::tatrc::physiology::datamodel::CircuitManager (s, m, f));

          ::xsd::cxx::tree::error_handler< char > h;

          ::xsd::cxx::xml::dom::ostream_format_target t (o);
          if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
          {
            h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
          }
        }

        void
        CircuitManager (::std::ostream& o,
                        const ::mil::tatrc::physiology::datamodel::CircuitManagerData& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0);

          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::mil::tatrc::physiology::datamodel::CircuitManager (s, m, f));
          ::xsd::cxx::xml::dom::ostream_format_target t (o);
          if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
          {
            throw ::xsd::cxx::tree::serialization< char > ();
          }
        }

        void
        CircuitManager (::std::ostream& o,
                        const ::mil::tatrc::physiology::datamodel::CircuitManagerData& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::mil::tatrc::physiology::datamodel::CircuitManager (s, m, f));
          ::xsd::cxx::xml::dom::ostream_format_target t (o);
          if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
          {
            throw ::xsd::cxx::tree::serialization< char > ();
          }
        }

        void
        CircuitManager (::xercesc::XMLFormatTarget& t,
                        const ::mil::tatrc::physiology::datamodel::CircuitManagerData& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::mil::tatrc::physiology::datamodel::CircuitManager (s, m, f));

          ::xsd::cxx::tree::error_handler< char > h;

          if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
          {
            h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
          }
        }

        void
        CircuitManager (::xercesc::XMLFormatTarget& t,
                        const ::mil::tatrc::physiology::datamodel::CircuitManagerData& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::mil::tatrc::physiology::datamodel::CircuitManager (s, m, f));
          if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
          {
            throw ::xsd::cxx::tree::serialization< char > ();
          }
        }

        void
        CircuitManager (::xercesc::XMLFormatTarget& t,
                        const ::mil::tatrc::physiology::datamodel::CircuitManagerData& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::mil::tatrc::physiology::datamodel::CircuitManager (s, m, f));
          if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
          {
            throw ::xsd::cxx::tree::serialization< char > ();
          }
        }

        void
        CircuitManager (::xercesc::DOMDocument& d,
                        const ::mil::tatrc::physiology::datamodel::CircuitManagerData& s,
                        ::xml_schema::flags)
        {
          ::xercesc::DOMElement& e (*d.getDocumentElement ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (e));

          if (typeid (::mil::tatrc::physiology::datamodel::CircuitManagerData) == typeid (s))
          {
            if (n.name () == "CircuitManager" &&
                n.namespace_ () == "uri:/mil/tatrc/physiology/datamodel")
            {
              e << s;
            }
            else
            {
              throw ::xsd::cxx::tree::unexpected_element < char > (
                n.name (),
                n.namespace_ (),
                "CircuitManager",
                "uri:/mil/tatrc/physiology/datamodel");
            }
          }
          else
          {
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
              "CircuitManager",
              "uri:/mil/tatrc/physiology/datamodel",
              e, n, s);
          }
        }

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
        CircuitManager (const ::mil::tatrc::physiology::datamodel::CircuitManagerData& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

          if (typeid (::mil::tatrc::physiology::datamodel::CircuitManagerData) == typeid (s))
          {
            d = ::xsd::cxx::xml::dom::serialize< char > (
              "CircuitManager",
              "uri:/mil/tatrc/physiology/datamodel",
              m, f);
          }
          else
          {
            d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
              "CircuitManager",
              "uri:/mil/tatrc/physiology/datamodel",
              m, s, f);
          }

          ::mil::tatrc::physiology::datamodel::CircuitManager (*d, s, f);
          return d;
        }
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

