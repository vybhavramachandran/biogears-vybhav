// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Patient.hxx"

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        // enumSex
        // 

        enumSex::
        enumSex ()
        : ::xml_schema::string ()
        {
        }

        enumSex::
        enumSex (value v)
        : ::xml_schema::string (_xsd_enumSex_literals_[v])
        {
        }

        enumSex::
        enumSex (const char* v)
        : ::xml_schema::string (v)
        {
        }

        enumSex::
        enumSex (const ::std::string& v)
        : ::xml_schema::string (v)
        {
        }

        enumSex::
        enumSex (const ::xml_schema::string& v)
        : ::xml_schema::string (v)
        {
        }

        enumSex::
        enumSex (const enumSex& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
        : ::xml_schema::string (v, f, c)
        {
        }

        enumSex& enumSex::
        operator= (value v)
        {
          static_cast< ::xml_schema::string& > (*this) = 
          ::xml_schema::string (_xsd_enumSex_literals_[v]);

          return *this;
        }


        // enumBloodType
        // 

        enumBloodType::
        enumBloodType ()
        : ::xml_schema::string ()
        {
        }

        enumBloodType::
        enumBloodType (value v)
        : ::xml_schema::string (_xsd_enumBloodType_literals_[v])
        {
        }

        enumBloodType::
        enumBloodType (const char* v)
        : ::xml_schema::string (v)
        {
        }

        enumBloodType::
        enumBloodType (const ::std::string& v)
        : ::xml_schema::string (v)
        {
        }

        enumBloodType::
        enumBloodType (const ::xml_schema::string& v)
        : ::xml_schema::string (v)
        {
        }

        enumBloodType::
        enumBloodType (const enumBloodType& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
        : ::xml_schema::string (v, f, c)
        {
        }

        enumBloodType& enumBloodType::
        operator= (value v)
        {
          static_cast< ::xml_schema::string& > (*this) = 
          ::xml_schema::string (_xsd_enumBloodType_literals_[v]);

          return *this;
        }


        // enumPatientEvent
        // 

        enumPatientEvent::
        enumPatientEvent ()
        : ::xml_schema::string ()
        {
        }

        enumPatientEvent::
        enumPatientEvent (value v)
        : ::xml_schema::string (_xsd_enumPatientEvent_literals_[v])
        {
        }

        enumPatientEvent::
        enumPatientEvent (const char* v)
        : ::xml_schema::string (v)
        {
        }

        enumPatientEvent::
        enumPatientEvent (const ::std::string& v)
        : ::xml_schema::string (v)
        {
        }

        enumPatientEvent::
        enumPatientEvent (const ::xml_schema::string& v)
        : ::xml_schema::string (v)
        {
        }

        enumPatientEvent::
        enumPatientEvent (const enumPatientEvent& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
        : ::xml_schema::string (v, f, c)
        {
        }

        enumPatientEvent& enumPatientEvent::
        operator= (value v)
        {
          static_cast< ::xml_schema::string& > (*this) = 
          ::xml_schema::string (_xsd_enumPatientEvent_literals_[v]);

          return *this;
        }


        // ActivePatientEventData
        // 

        const ActivePatientEventData::Duration_type& ActivePatientEventData::
        Duration () const
        {
          return this->Duration_.get ();
        }

        ActivePatientEventData::Duration_type& ActivePatientEventData::
        Duration ()
        {
          return this->Duration_.get ();
        }

        void ActivePatientEventData::
        Duration (const Duration_type& x)
        {
          this->Duration_.set (x);
        }

        void ActivePatientEventData::
        Duration (::std::unique_ptr< Duration_type > x)
        {
          this->Duration_.set (std::move (x));
        }

        const ActivePatientEventData::Event_type& ActivePatientEventData::
        Event () const
        {
          return this->Event_.get ();
        }

        ActivePatientEventData::Event_type& ActivePatientEventData::
        Event ()
        {
          return this->Event_.get ();
        }

        void ActivePatientEventData::
        Event (const Event_type& x)
        {
          this->Event_.set (x);
        }

        void ActivePatientEventData::
        Event (::std::unique_ptr< Event_type > x)
        {
          this->Event_.set (std::move (x));
        }


        // PatientData
        // 

        const PatientData::Annotation_optional& PatientData::
        Annotation () const
        {
          return this->Annotation_;
        }

        PatientData::Annotation_optional& PatientData::
        Annotation ()
        {
          return this->Annotation_;
        }

        void PatientData::
        Annotation (const Annotation_type& x)
        {
          this->Annotation_.set (x);
        }

        void PatientData::
        Annotation (const Annotation_optional& x)
        {
          this->Annotation_ = x;
        }

        void PatientData::
        Annotation (::std::unique_ptr< Annotation_type > x)
        {
          this->Annotation_.set (std::move (x));
        }

        const PatientData::Name_type& PatientData::
        Name () const
        {
          return this->Name_.get ();
        }

        PatientData::Name_type& PatientData::
        Name ()
        {
          return this->Name_.get ();
        }

        void PatientData::
        Name (const Name_type& x)
        {
          this->Name_.set (x);
        }

        void PatientData::
        Name (::std::unique_ptr< Name_type > x)
        {
          this->Name_.set (std::move (x));
        }

        const PatientData::Sex_optional& PatientData::
        Sex () const
        {
          return this->Sex_;
        }

        PatientData::Sex_optional& PatientData::
        Sex ()
        {
          return this->Sex_;
        }

        void PatientData::
        Sex (const Sex_type& x)
        {
          this->Sex_.set (x);
        }

        void PatientData::
        Sex (const Sex_optional& x)
        {
          this->Sex_ = x;
        }

        void PatientData::
        Sex (::std::unique_ptr< Sex_type > x)
        {
          this->Sex_.set (std::move (x));
        }

        const PatientData::Age_optional& PatientData::
        Age () const
        {
          return this->Age_;
        }

        PatientData::Age_optional& PatientData::
        Age ()
        {
          return this->Age_;
        }

        void PatientData::
        Age (const Age_type& x)
        {
          this->Age_.set (x);
        }

        void PatientData::
        Age (const Age_optional& x)
        {
          this->Age_ = x;
        }

        void PatientData::
        Age (::std::unique_ptr< Age_type > x)
        {
          this->Age_.set (std::move (x));
        }

        const PatientData::Weight_optional& PatientData::
        Weight () const
        {
          return this->Weight_;
        }

        PatientData::Weight_optional& PatientData::
        Weight ()
        {
          return this->Weight_;
        }

        void PatientData::
        Weight (const Weight_type& x)
        {
          this->Weight_.set (x);
        }

        void PatientData::
        Weight (const Weight_optional& x)
        {
          this->Weight_ = x;
        }

        void PatientData::
        Weight (::std::unique_ptr< Weight_type > x)
        {
          this->Weight_.set (std::move (x));
        }

        const PatientData::Height_optional& PatientData::
        Height () const
        {
          return this->Height_;
        }

        PatientData::Height_optional& PatientData::
        Height ()
        {
          return this->Height_;
        }

        void PatientData::
        Height (const Height_type& x)
        {
          this->Height_.set (x);
        }

        void PatientData::
        Height (const Height_optional& x)
        {
          this->Height_ = x;
        }

        void PatientData::
        Height (::std::unique_ptr< Height_type > x)
        {
          this->Height_.set (std::move (x));
        }

        const PatientData::BodyDensity_optional& PatientData::
        BodyDensity () const
        {
          return this->BodyDensity_;
        }

        PatientData::BodyDensity_optional& PatientData::
        BodyDensity ()
        {
          return this->BodyDensity_;
        }

        void PatientData::
        BodyDensity (const BodyDensity_type& x)
        {
          this->BodyDensity_.set (x);
        }

        void PatientData::
        BodyDensity (const BodyDensity_optional& x)
        {
          this->BodyDensity_ = x;
        }

        void PatientData::
        BodyDensity (::std::unique_ptr< BodyDensity_type > x)
        {
          this->BodyDensity_.set (std::move (x));
        }

        const PatientData::BodyFatFraction_optional& PatientData::
        BodyFatFraction () const
        {
          return this->BodyFatFraction_;
        }

        PatientData::BodyFatFraction_optional& PatientData::
        BodyFatFraction ()
        {
          return this->BodyFatFraction_;
        }

        void PatientData::
        BodyFatFraction (const BodyFatFraction_type& x)
        {
          this->BodyFatFraction_.set (x);
        }

        void PatientData::
        BodyFatFraction (const BodyFatFraction_optional& x)
        {
          this->BodyFatFraction_ = x;
        }

        void PatientData::
        BodyFatFraction (::std::unique_ptr< BodyFatFraction_type > x)
        {
          this->BodyFatFraction_.set (std::move (x));
        }

        const PatientData::LeanBodyMass_optional& PatientData::
        LeanBodyMass () const
        {
          return this->LeanBodyMass_;
        }

        PatientData::LeanBodyMass_optional& PatientData::
        LeanBodyMass ()
        {
          return this->LeanBodyMass_;
        }

        void PatientData::
        LeanBodyMass (const LeanBodyMass_type& x)
        {
          this->LeanBodyMass_.set (x);
        }

        void PatientData::
        LeanBodyMass (const LeanBodyMass_optional& x)
        {
          this->LeanBodyMass_ = x;
        }

        void PatientData::
        LeanBodyMass (::std::unique_ptr< LeanBodyMass_type > x)
        {
          this->LeanBodyMass_.set (std::move (x));
        }

        const PatientData::MaxWorkRate_optional& PatientData::
        MaxWorkRate () const
        {
          return this->MaxWorkRate_;
        }

        PatientData::MaxWorkRate_optional& PatientData::
        MaxWorkRate ()
        {
          return this->MaxWorkRate_;
        }

        void PatientData::
        MaxWorkRate (const MaxWorkRate_type& x)
        {
          this->MaxWorkRate_.set (x);
        }

        void PatientData::
        MaxWorkRate (const MaxWorkRate_optional& x)
        {
          this->MaxWorkRate_ = x;
        }

        void PatientData::
        MaxWorkRate (::std::unique_ptr< MaxWorkRate_type > x)
        {
          this->MaxWorkRate_.set (std::move (x));
        }

        const PatientData::MuscleMass_optional& PatientData::
        MuscleMass () const
        {
          return this->MuscleMass_;
        }

        PatientData::MuscleMass_optional& PatientData::
        MuscleMass ()
        {
          return this->MuscleMass_;
        }

        void PatientData::
        MuscleMass (const MuscleMass_type& x)
        {
          this->MuscleMass_.set (x);
        }

        void PatientData::
        MuscleMass (const MuscleMass_optional& x)
        {
          this->MuscleMass_ = x;
        }

        void PatientData::
        MuscleMass (::std::unique_ptr< MuscleMass_type > x)
        {
          this->MuscleMass_.set (std::move (x));
        }

        const PatientData::BloodTypeABO_optional& PatientData::
        BloodTypeABO () const
        {
          return this->BloodTypeABO_;
        }

        PatientData::BloodTypeABO_optional& PatientData::
        BloodTypeABO ()
        {
          return this->BloodTypeABO_;
        }

        void PatientData::
        BloodTypeABO (const BloodTypeABO_type& x)
        {
          this->BloodTypeABO_.set (x);
        }

        void PatientData::
        BloodTypeABO (const BloodTypeABO_optional& x)
        {
          this->BloodTypeABO_ = x;
        }

        void PatientData::
        BloodTypeABO (::std::unique_ptr< BloodTypeABO_type > x)
        {
          this->BloodTypeABO_.set (std::move (x));
        }

        const PatientData::BloodTypeRh_optional& PatientData::
        BloodTypeRh () const
        {
          return this->BloodTypeRh_;
        }

        PatientData::BloodTypeRh_optional& PatientData::
        BloodTypeRh ()
        {
          return this->BloodTypeRh_;
        }

        void PatientData::
        BloodTypeRh (const BloodTypeRh_type& x)
        {
          this->BloodTypeRh_.set (x);
        }

        void PatientData::
        BloodTypeRh (const BloodTypeRh_optional& x)
        {
          this->BloodTypeRh_ = x;
        }

        const PatientData::AlveoliSurfaceArea_optional& PatientData::
        AlveoliSurfaceArea () const
        {
          return this->AlveoliSurfaceArea_;
        }

        PatientData::AlveoliSurfaceArea_optional& PatientData::
        AlveoliSurfaceArea ()
        {
          return this->AlveoliSurfaceArea_;
        }

        void PatientData::
        AlveoliSurfaceArea (const AlveoliSurfaceArea_type& x)
        {
          this->AlveoliSurfaceArea_.set (x);
        }

        void PatientData::
        AlveoliSurfaceArea (const AlveoliSurfaceArea_optional& x)
        {
          this->AlveoliSurfaceArea_ = x;
        }

        void PatientData::
        AlveoliSurfaceArea (::std::unique_ptr< AlveoliSurfaceArea_type > x)
        {
          this->AlveoliSurfaceArea_.set (std::move (x));
        }

        const PatientData::Hyperhidrosis_optional& PatientData::
        Hyperhidrosis () const
        {
          return this->Hyperhidrosis_;
        }

        PatientData::Hyperhidrosis_optional& PatientData::
        Hyperhidrosis ()
        {
          return this->Hyperhidrosis_;
        }

        void PatientData::
        Hyperhidrosis (const Hyperhidrosis_type& x)
        {
          this->Hyperhidrosis_.set (x);
        }

        void PatientData::
        Hyperhidrosis (const Hyperhidrosis_optional& x)
        {
          this->Hyperhidrosis_ = x;
        }

        void PatientData::
        Hyperhidrosis (::std::unique_ptr< Hyperhidrosis_type > x)
        {
          this->Hyperhidrosis_.set (std::move (x));
        }

        const PatientData::RightLungRatio_optional& PatientData::
        RightLungRatio () const
        {
          return this->RightLungRatio_;
        }

        PatientData::RightLungRatio_optional& PatientData::
        RightLungRatio ()
        {
          return this->RightLungRatio_;
        }

        void PatientData::
        RightLungRatio (const RightLungRatio_type& x)
        {
          this->RightLungRatio_.set (x);
        }

        void PatientData::
        RightLungRatio (const RightLungRatio_optional& x)
        {
          this->RightLungRatio_ = x;
        }

        void PatientData::
        RightLungRatio (::std::unique_ptr< RightLungRatio_type > x)
        {
          this->RightLungRatio_.set (std::move (x));
        }

        const PatientData::SkinSurfaceArea_optional& PatientData::
        SkinSurfaceArea () const
        {
          return this->SkinSurfaceArea_;
        }

        PatientData::SkinSurfaceArea_optional& PatientData::
        SkinSurfaceArea ()
        {
          return this->SkinSurfaceArea_;
        }

        void PatientData::
        SkinSurfaceArea (const SkinSurfaceArea_type& x)
        {
          this->SkinSurfaceArea_.set (x);
        }

        void PatientData::
        SkinSurfaceArea (const SkinSurfaceArea_optional& x)
        {
          this->SkinSurfaceArea_ = x;
        }

        void PatientData::
        SkinSurfaceArea (::std::unique_ptr< SkinSurfaceArea_type > x)
        {
          this->SkinSurfaceArea_.set (std::move (x));
        }

        const PatientData::SleepAmount_optional& PatientData::
        SleepAmount () const
        {
          return this->SleepAmount_;
        }

        PatientData::SleepAmount_optional& PatientData::
        SleepAmount ()
        {
          return this->SleepAmount_;
        }

        void PatientData::
        SleepAmount (const SleepAmount_type& x)
        {
          this->SleepAmount_.set (x);
        }

        void PatientData::
        SleepAmount (const SleepAmount_optional& x)
        {
          this->SleepAmount_ = x;
        }

        void PatientData::
        SleepAmount (::std::unique_ptr< SleepAmount_type > x)
        {
          this->SleepAmount_.set (std::move (x));
        }

        const PatientData::PainSusceptibility_optional& PatientData::
        PainSusceptibility () const
        {
          return this->PainSusceptibility_;
        }

        PatientData::PainSusceptibility_optional& PatientData::
        PainSusceptibility ()
        {
          return this->PainSusceptibility_;
        }

        void PatientData::
        PainSusceptibility (const PainSusceptibility_type& x)
        {
          this->PainSusceptibility_.set (x);
        }

        void PatientData::
        PainSusceptibility (const PainSusceptibility_optional& x)
        {
          this->PainSusceptibility_ = x;
        }

        void PatientData::
        PainSusceptibility (::std::unique_ptr< PainSusceptibility_type > x)
        {
          this->PainSusceptibility_.set (std::move (x));
        }

        const PatientData::BasalMetabolicRate_optional& PatientData::
        BasalMetabolicRate () const
        {
          return this->BasalMetabolicRate_;
        }

        PatientData::BasalMetabolicRate_optional& PatientData::
        BasalMetabolicRate ()
        {
          return this->BasalMetabolicRate_;
        }

        void PatientData::
        BasalMetabolicRate (const BasalMetabolicRate_type& x)
        {
          this->BasalMetabolicRate_.set (x);
        }

        void PatientData::
        BasalMetabolicRate (const BasalMetabolicRate_optional& x)
        {
          this->BasalMetabolicRate_ = x;
        }

        void PatientData::
        BasalMetabolicRate (::std::unique_ptr< BasalMetabolicRate_type > x)
        {
          this->BasalMetabolicRate_.set (std::move (x));
        }

        const PatientData::BloodVolumeBaseline_optional& PatientData::
        BloodVolumeBaseline () const
        {
          return this->BloodVolumeBaseline_;
        }

        PatientData::BloodVolumeBaseline_optional& PatientData::
        BloodVolumeBaseline ()
        {
          return this->BloodVolumeBaseline_;
        }

        void PatientData::
        BloodVolumeBaseline (const BloodVolumeBaseline_type& x)
        {
          this->BloodVolumeBaseline_.set (x);
        }

        void PatientData::
        BloodVolumeBaseline (const BloodVolumeBaseline_optional& x)
        {
          this->BloodVolumeBaseline_ = x;
        }

        void PatientData::
        BloodVolumeBaseline (::std::unique_ptr< BloodVolumeBaseline_type > x)
        {
          this->BloodVolumeBaseline_.set (std::move (x));
        }

        const PatientData::DiastolicArterialPressureBaseline_optional& PatientData::
        DiastolicArterialPressureBaseline () const
        {
          return this->DiastolicArterialPressureBaseline_;
        }

        PatientData::DiastolicArterialPressureBaseline_optional& PatientData::
        DiastolicArterialPressureBaseline ()
        {
          return this->DiastolicArterialPressureBaseline_;
        }

        void PatientData::
        DiastolicArterialPressureBaseline (const DiastolicArterialPressureBaseline_type& x)
        {
          this->DiastolicArterialPressureBaseline_.set (x);
        }

        void PatientData::
        DiastolicArterialPressureBaseline (const DiastolicArterialPressureBaseline_optional& x)
        {
          this->DiastolicArterialPressureBaseline_ = x;
        }

        void PatientData::
        DiastolicArterialPressureBaseline (::std::unique_ptr< DiastolicArterialPressureBaseline_type > x)
        {
          this->DiastolicArterialPressureBaseline_.set (std::move (x));
        }

        const PatientData::HeartRateBaseline_optional& PatientData::
        HeartRateBaseline () const
        {
          return this->HeartRateBaseline_;
        }

        PatientData::HeartRateBaseline_optional& PatientData::
        HeartRateBaseline ()
        {
          return this->HeartRateBaseline_;
        }

        void PatientData::
        HeartRateBaseline (const HeartRateBaseline_type& x)
        {
          this->HeartRateBaseline_.set (x);
        }

        void PatientData::
        HeartRateBaseline (const HeartRateBaseline_optional& x)
        {
          this->HeartRateBaseline_ = x;
        }

        void PatientData::
        HeartRateBaseline (::std::unique_ptr< HeartRateBaseline_type > x)
        {
          this->HeartRateBaseline_.set (std::move (x));
        }

        const PatientData::MeanArterialPressureBaseline_optional& PatientData::
        MeanArterialPressureBaseline () const
        {
          return this->MeanArterialPressureBaseline_;
        }

        PatientData::MeanArterialPressureBaseline_optional& PatientData::
        MeanArterialPressureBaseline ()
        {
          return this->MeanArterialPressureBaseline_;
        }

        void PatientData::
        MeanArterialPressureBaseline (const MeanArterialPressureBaseline_type& x)
        {
          this->MeanArterialPressureBaseline_.set (x);
        }

        void PatientData::
        MeanArterialPressureBaseline (const MeanArterialPressureBaseline_optional& x)
        {
          this->MeanArterialPressureBaseline_ = x;
        }

        void PatientData::
        MeanArterialPressureBaseline (::std::unique_ptr< MeanArterialPressureBaseline_type > x)
        {
          this->MeanArterialPressureBaseline_.set (std::move (x));
        }

        const PatientData::RespirationRateBaseline_optional& PatientData::
        RespirationRateBaseline () const
        {
          return this->RespirationRateBaseline_;
        }

        PatientData::RespirationRateBaseline_optional& PatientData::
        RespirationRateBaseline ()
        {
          return this->RespirationRateBaseline_;
        }

        void PatientData::
        RespirationRateBaseline (const RespirationRateBaseline_type& x)
        {
          this->RespirationRateBaseline_.set (x);
        }

        void PatientData::
        RespirationRateBaseline (const RespirationRateBaseline_optional& x)
        {
          this->RespirationRateBaseline_ = x;
        }

        void PatientData::
        RespirationRateBaseline (::std::unique_ptr< RespirationRateBaseline_type > x)
        {
          this->RespirationRateBaseline_.set (std::move (x));
        }

        const PatientData::SystolicArterialPressureBaseline_optional& PatientData::
        SystolicArterialPressureBaseline () const
        {
          return this->SystolicArterialPressureBaseline_;
        }

        PatientData::SystolicArterialPressureBaseline_optional& PatientData::
        SystolicArterialPressureBaseline ()
        {
          return this->SystolicArterialPressureBaseline_;
        }

        void PatientData::
        SystolicArterialPressureBaseline (const SystolicArterialPressureBaseline_type& x)
        {
          this->SystolicArterialPressureBaseline_.set (x);
        }

        void PatientData::
        SystolicArterialPressureBaseline (const SystolicArterialPressureBaseline_optional& x)
        {
          this->SystolicArterialPressureBaseline_ = x;
        }

        void PatientData::
        SystolicArterialPressureBaseline (::std::unique_ptr< SystolicArterialPressureBaseline_type > x)
        {
          this->SystolicArterialPressureBaseline_.set (std::move (x));
        }

        const PatientData::TidalVolumeBaseline_optional& PatientData::
        TidalVolumeBaseline () const
        {
          return this->TidalVolumeBaseline_;
        }

        PatientData::TidalVolumeBaseline_optional& PatientData::
        TidalVolumeBaseline ()
        {
          return this->TidalVolumeBaseline_;
        }

        void PatientData::
        TidalVolumeBaseline (const TidalVolumeBaseline_type& x)
        {
          this->TidalVolumeBaseline_.set (x);
        }

        void PatientData::
        TidalVolumeBaseline (const TidalVolumeBaseline_optional& x)
        {
          this->TidalVolumeBaseline_ = x;
        }

        void PatientData::
        TidalVolumeBaseline (::std::unique_ptr< TidalVolumeBaseline_type > x)
        {
          this->TidalVolumeBaseline_.set (std::move (x));
        }

        const PatientData::HeartRateMaximum_optional& PatientData::
        HeartRateMaximum () const
        {
          return this->HeartRateMaximum_;
        }

        PatientData::HeartRateMaximum_optional& PatientData::
        HeartRateMaximum ()
        {
          return this->HeartRateMaximum_;
        }

        void PatientData::
        HeartRateMaximum (const HeartRateMaximum_type& x)
        {
          this->HeartRateMaximum_.set (x);
        }

        void PatientData::
        HeartRateMaximum (const HeartRateMaximum_optional& x)
        {
          this->HeartRateMaximum_ = x;
        }

        void PatientData::
        HeartRateMaximum (::std::unique_ptr< HeartRateMaximum_type > x)
        {
          this->HeartRateMaximum_.set (std::move (x));
        }

        const PatientData::HeartRateMinimum_optional& PatientData::
        HeartRateMinimum () const
        {
          return this->HeartRateMinimum_;
        }

        PatientData::HeartRateMinimum_optional& PatientData::
        HeartRateMinimum ()
        {
          return this->HeartRateMinimum_;
        }

        void PatientData::
        HeartRateMinimum (const HeartRateMinimum_type& x)
        {
          this->HeartRateMinimum_.set (x);
        }

        void PatientData::
        HeartRateMinimum (const HeartRateMinimum_optional& x)
        {
          this->HeartRateMinimum_ = x;
        }

        void PatientData::
        HeartRateMinimum (::std::unique_ptr< HeartRateMinimum_type > x)
        {
          this->HeartRateMinimum_.set (std::move (x));
        }

        const PatientData::ExpiratoryReserveVolume_optional& PatientData::
        ExpiratoryReserveVolume () const
        {
          return this->ExpiratoryReserveVolume_;
        }

        PatientData::ExpiratoryReserveVolume_optional& PatientData::
        ExpiratoryReserveVolume ()
        {
          return this->ExpiratoryReserveVolume_;
        }

        void PatientData::
        ExpiratoryReserveVolume (const ExpiratoryReserveVolume_type& x)
        {
          this->ExpiratoryReserveVolume_.set (x);
        }

        void PatientData::
        ExpiratoryReserveVolume (const ExpiratoryReserveVolume_optional& x)
        {
          this->ExpiratoryReserveVolume_ = x;
        }

        void PatientData::
        ExpiratoryReserveVolume (::std::unique_ptr< ExpiratoryReserveVolume_type > x)
        {
          this->ExpiratoryReserveVolume_.set (std::move (x));
        }

        const PatientData::FunctionalResidualCapacity_optional& PatientData::
        FunctionalResidualCapacity () const
        {
          return this->FunctionalResidualCapacity_;
        }

        PatientData::FunctionalResidualCapacity_optional& PatientData::
        FunctionalResidualCapacity ()
        {
          return this->FunctionalResidualCapacity_;
        }

        void PatientData::
        FunctionalResidualCapacity (const FunctionalResidualCapacity_type& x)
        {
          this->FunctionalResidualCapacity_.set (x);
        }

        void PatientData::
        FunctionalResidualCapacity (const FunctionalResidualCapacity_optional& x)
        {
          this->FunctionalResidualCapacity_ = x;
        }

        void PatientData::
        FunctionalResidualCapacity (::std::unique_ptr< FunctionalResidualCapacity_type > x)
        {
          this->FunctionalResidualCapacity_.set (std::move (x));
        }

        const PatientData::InspiratoryCapacity_optional& PatientData::
        InspiratoryCapacity () const
        {
          return this->InspiratoryCapacity_;
        }

        PatientData::InspiratoryCapacity_optional& PatientData::
        InspiratoryCapacity ()
        {
          return this->InspiratoryCapacity_;
        }

        void PatientData::
        InspiratoryCapacity (const InspiratoryCapacity_type& x)
        {
          this->InspiratoryCapacity_.set (x);
        }

        void PatientData::
        InspiratoryCapacity (const InspiratoryCapacity_optional& x)
        {
          this->InspiratoryCapacity_ = x;
        }

        void PatientData::
        InspiratoryCapacity (::std::unique_ptr< InspiratoryCapacity_type > x)
        {
          this->InspiratoryCapacity_.set (std::move (x));
        }

        const PatientData::InspiratoryReserveVolume_optional& PatientData::
        InspiratoryReserveVolume () const
        {
          return this->InspiratoryReserveVolume_;
        }

        PatientData::InspiratoryReserveVolume_optional& PatientData::
        InspiratoryReserveVolume ()
        {
          return this->InspiratoryReserveVolume_;
        }

        void PatientData::
        InspiratoryReserveVolume (const InspiratoryReserveVolume_type& x)
        {
          this->InspiratoryReserveVolume_.set (x);
        }

        void PatientData::
        InspiratoryReserveVolume (const InspiratoryReserveVolume_optional& x)
        {
          this->InspiratoryReserveVolume_ = x;
        }

        void PatientData::
        InspiratoryReserveVolume (::std::unique_ptr< InspiratoryReserveVolume_type > x)
        {
          this->InspiratoryReserveVolume_.set (std::move (x));
        }

        const PatientData::ResidualVolume_optional& PatientData::
        ResidualVolume () const
        {
          return this->ResidualVolume_;
        }

        PatientData::ResidualVolume_optional& PatientData::
        ResidualVolume ()
        {
          return this->ResidualVolume_;
        }

        void PatientData::
        ResidualVolume (const ResidualVolume_type& x)
        {
          this->ResidualVolume_.set (x);
        }

        void PatientData::
        ResidualVolume (const ResidualVolume_optional& x)
        {
          this->ResidualVolume_ = x;
        }

        void PatientData::
        ResidualVolume (::std::unique_ptr< ResidualVolume_type > x)
        {
          this->ResidualVolume_.set (std::move (x));
        }

        const PatientData::RespiratoryDriverAmplitudeBaseline_optional& PatientData::
        RespiratoryDriverAmplitudeBaseline () const
        {
          return this->RespiratoryDriverAmplitudeBaseline_;
        }

        PatientData::RespiratoryDriverAmplitudeBaseline_optional& PatientData::
        RespiratoryDriverAmplitudeBaseline ()
        {
          return this->RespiratoryDriverAmplitudeBaseline_;
        }

        void PatientData::
        RespiratoryDriverAmplitudeBaseline (const RespiratoryDriverAmplitudeBaseline_type& x)
        {
          this->RespiratoryDriverAmplitudeBaseline_.set (x);
        }

        void PatientData::
        RespiratoryDriverAmplitudeBaseline (const RespiratoryDriverAmplitudeBaseline_optional& x)
        {
          this->RespiratoryDriverAmplitudeBaseline_ = x;
        }

        void PatientData::
        RespiratoryDriverAmplitudeBaseline (::std::unique_ptr< RespiratoryDriverAmplitudeBaseline_type > x)
        {
          this->RespiratoryDriverAmplitudeBaseline_.set (std::move (x));
        }

        const PatientData::TotalLungCapacity_optional& PatientData::
        TotalLungCapacity () const
        {
          return this->TotalLungCapacity_;
        }

        PatientData::TotalLungCapacity_optional& PatientData::
        TotalLungCapacity ()
        {
          return this->TotalLungCapacity_;
        }

        void PatientData::
        TotalLungCapacity (const TotalLungCapacity_type& x)
        {
          this->TotalLungCapacity_.set (x);
        }

        void PatientData::
        TotalLungCapacity (const TotalLungCapacity_optional& x)
        {
          this->TotalLungCapacity_ = x;
        }

        void PatientData::
        TotalLungCapacity (::std::unique_ptr< TotalLungCapacity_type > x)
        {
          this->TotalLungCapacity_.set (std::move (x));
        }

        const PatientData::TotalVentilationBaseline_optional& PatientData::
        TotalVentilationBaseline () const
        {
          return this->TotalVentilationBaseline_;
        }

        PatientData::TotalVentilationBaseline_optional& PatientData::
        TotalVentilationBaseline ()
        {
          return this->TotalVentilationBaseline_;
        }

        void PatientData::
        TotalVentilationBaseline (const TotalVentilationBaseline_type& x)
        {
          this->TotalVentilationBaseline_.set (x);
        }

        void PatientData::
        TotalVentilationBaseline (const TotalVentilationBaseline_optional& x)
        {
          this->TotalVentilationBaseline_ = x;
        }

        void PatientData::
        TotalVentilationBaseline (::std::unique_ptr< TotalVentilationBaseline_type > x)
        {
          this->TotalVentilationBaseline_.set (std::move (x));
        }

        const PatientData::VitalCapacity_optional& PatientData::
        VitalCapacity () const
        {
          return this->VitalCapacity_;
        }

        PatientData::VitalCapacity_optional& PatientData::
        VitalCapacity ()
        {
          return this->VitalCapacity_;
        }

        void PatientData::
        VitalCapacity (const VitalCapacity_type& x)
        {
          this->VitalCapacity_.set (x);
        }

        void PatientData::
        VitalCapacity (const VitalCapacity_optional& x)
        {
          this->VitalCapacity_ = x;
        }

        void PatientData::
        VitalCapacity (::std::unique_ptr< VitalCapacity_type > x)
        {
          this->VitalCapacity_.set (std::move (x));
        }

        const PatientData::ActiveEvent_sequence& PatientData::
        ActiveEvent () const
        {
          return this->ActiveEvent_;
        }

        PatientData::ActiveEvent_sequence& PatientData::
        ActiveEvent ()
        {
          return this->ActiveEvent_;
        }

        void PatientData::
        ActiveEvent (const ActiveEvent_sequence& s)
        {
          this->ActiveEvent_ = s;
        }
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        // enumSex
        //

        enumSex::
        enumSex (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
        : ::xml_schema::string (e, f, c)
        {
          _xsd_enumSex_convert ();
        }

        enumSex::
        enumSex (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
        : ::xml_schema::string (a, f, c)
        {
          _xsd_enumSex_convert ();
        }

        enumSex::
        enumSex (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
        : ::xml_schema::string (s, e, f, c)
        {
          _xsd_enumSex_convert ();
        }

        enumSex* enumSex::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class enumSex (*this, f, c);
        }

        enumSex::value enumSex::
        _xsd_enumSex_convert () const
        {
          ::xsd::cxx::tree::enum_comparator< char > c (_xsd_enumSex_literals_);
          const value* i (::std::lower_bound (
                            _xsd_enumSex_indexes_,
                            _xsd_enumSex_indexes_ + 2,
                            *this,
                            c));

          if (i == _xsd_enumSex_indexes_ + 2 || _xsd_enumSex_literals_[*i] != *this)
          {
            throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
          }

          return *i;
        }

        const char* const enumSex::
        _xsd_enumSex_literals_[2] =
        {
          "Male",
          "Female"
        };

        const enumSex::value enumSex::
        _xsd_enumSex_indexes_[2] =
        {
          ::mil::tatrc::physiology::datamodel::enumSex::Female,
          ::mil::tatrc::physiology::datamodel::enumSex::Male
        };

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, enumSex >
        _xsd_enumSex_type_factory_init (
          "enumSex",
          "uri:/mil/tatrc/physiology/datamodel");

        // enumBloodType
        //

        enumBloodType::
        enumBloodType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
        : ::xml_schema::string (e, f, c)
        {
          _xsd_enumBloodType_convert ();
        }

        enumBloodType::
        enumBloodType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
        : ::xml_schema::string (a, f, c)
        {
          _xsd_enumBloodType_convert ();
        }

        enumBloodType::
        enumBloodType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
        : ::xml_schema::string (s, e, f, c)
        {
          _xsd_enumBloodType_convert ();
        }

        enumBloodType* enumBloodType::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class enumBloodType (*this, f, c);
        }

        enumBloodType::value enumBloodType::
        _xsd_enumBloodType_convert () const
        {
          ::xsd::cxx::tree::enum_comparator< char > c (_xsd_enumBloodType_literals_);
          const value* i (::std::lower_bound (
                            _xsd_enumBloodType_indexes_,
                            _xsd_enumBloodType_indexes_ + 4,
                            *this,
                            c));

          if (i == _xsd_enumBloodType_indexes_ + 4 || _xsd_enumBloodType_literals_[*i] != *this)
          {
            throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
          }

          return *i;
        }

        const char* const enumBloodType::
        _xsd_enumBloodType_literals_[4] =
        {
          "A",
          "B",
          "AB",
          "O"
        };

        const enumBloodType::value enumBloodType::
        _xsd_enumBloodType_indexes_[4] =
        {
          ::mil::tatrc::physiology::datamodel::enumBloodType::A,
          ::mil::tatrc::physiology::datamodel::enumBloodType::AB,
          ::mil::tatrc::physiology::datamodel::enumBloodType::B,
          ::mil::tatrc::physiology::datamodel::enumBloodType::O
        };

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, enumBloodType >
        _xsd_enumBloodType_type_factory_init (
          "enumBloodType",
          "uri:/mil/tatrc/physiology/datamodel");

        // enumPatientEvent
        //

        enumPatientEvent::
        enumPatientEvent (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
        : ::xml_schema::string (e, f, c)
        {
          _xsd_enumPatientEvent_convert ();
        }

        enumPatientEvent::
        enumPatientEvent (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
        : ::xml_schema::string (a, f, c)
        {
          _xsd_enumPatientEvent_convert ();
        }

        enumPatientEvent::
        enumPatientEvent (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
        : ::xml_schema::string (s, e, f, c)
        {
          _xsd_enumPatientEvent_convert ();
        }

        enumPatientEvent* enumPatientEvent::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class enumPatientEvent (*this, f, c);
        }

        enumPatientEvent::value enumPatientEvent::
        _xsd_enumPatientEvent_convert () const
        {
          ::xsd::cxx::tree::enum_comparator< char > c (_xsd_enumPatientEvent_literals_);
          const value* i (::std::lower_bound (
                            _xsd_enumPatientEvent_indexes_,
                            _xsd_enumPatientEvent_indexes_ + 59,
                            *this,
                            c));

          if (i == _xsd_enumPatientEvent_indexes_ + 59 || _xsd_enumPatientEvent_literals_[*i] != *this)
          {
            throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
          }

          return *i;
        }

        const char* const enumPatientEvent::
        _xsd_enumPatientEvent_literals_[59] =
        {
          "AcuteLungInjury",
          "AcuteRespiratoryDistress",
          "Antidiuresis",
          "Asystole",
          "Bradycardia",
          "Bradypnea",
          "BrainOxygenDeficit",
          "CardiacArrest",
          "CardiogenicShock",
          "CriticalBrainOxygenDeficit",
          "Dehydration",
          "Diuresis",
          "Fasciculation",
          "Fatigue",
          "FunctionalIncontinence",
          "HemolyticTransfusionReaction",
          "Hypercapnia",
          "Hyperglycemia",
          "MildHyperkalemia",
          "SevereHyperkalemia",
          "MildHypernatremia",
          "SevereHypernatremia",
          "Hyperthermia",
          "Hypoglycemia",
          "HypoglycemicShock",
          "HypoglycemicComa",
          "Hypothermia",
          "MildHypokalemia",
          "SevereHypokalemia",
          "MildHyponatremia",
          "SevereHyponatremia",
          "Hypoxia",
          "HypovolemicShock",
          "IntracranialHypertension",
          "IntracranialHypotension",
          "IrreversibleState",
          "Ketoacidosis",
          "LacticAcidosis",
          "LiverGlycogenDepleted",
          "MaximumPulmonaryVentilationRate",
          "MetabolicAcidosis",
          "MetabolicAlkalosis",
          "MuscleCatabolism",
          "MuscleGlycogenDepleted",
          "MyocardiumOxygenDeficit",
          "Natriuresis",
          "NutritionDepleted",
          "PulselessRhythm",
          "RenalHypoperfusion",
          "RespiratoryAcidosis",
          "RespiratoryAlkalosis",
          "SevereAcuteRespiratoryDistress",
          "StartOfCardiacCycle",
          "StartOfExhale",
          "StartOfInhale",
          "SevereSepsis",
          "Tachycardia",
          "Tachypnea",
          "TotalPatientEvents"
        };

        const enumPatientEvent::value enumPatientEvent::
        _xsd_enumPatientEvent_indexes_[59] =
        {
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::AcuteLungInjury,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::AcuteRespiratoryDistress,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Antidiuresis,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Asystole,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Bradycardia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Bradypnea,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::BrainOxygenDeficit,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::CardiacArrest,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::CardiogenicShock,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::CriticalBrainOxygenDeficit,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Dehydration,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Diuresis,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Fasciculation,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Fatigue,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::FunctionalIncontinence,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::HemolyticTransfusionReaction,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Hypercapnia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Hyperglycemia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Hyperthermia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Hypoglycemia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::HypoglycemicComa,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::HypoglycemicShock,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Hypothermia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::HypovolemicShock,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Hypoxia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::IntracranialHypertension,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::IntracranialHypotension,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::IrreversibleState,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Ketoacidosis,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::LacticAcidosis,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::LiverGlycogenDepleted,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::MaximumPulmonaryVentilationRate,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::MetabolicAcidosis,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::MetabolicAlkalosis,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::MildHyperkalemia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::MildHypernatremia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::MildHypokalemia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::MildHyponatremia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::MuscleCatabolism,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::MuscleGlycogenDepleted,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::MyocardiumOxygenDeficit,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Natriuresis,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::NutritionDepleted,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::PulselessRhythm,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::RenalHypoperfusion,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::RespiratoryAcidosis,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::RespiratoryAlkalosis,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::SevereAcuteRespiratoryDistress,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::SevereHyperkalemia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::SevereHypernatremia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::SevereHypokalemia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::SevereHyponatremia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::SevereSepsis,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::StartOfCardiacCycle,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::StartOfExhale,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::StartOfInhale,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Tachycardia,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::Tachypnea,
          ::mil::tatrc::physiology::datamodel::enumPatientEvent::TotalPatientEvents
        };

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, enumPatientEvent >
        _xsd_enumPatientEvent_type_factory_init (
          "enumPatientEvent",
          "uri:/mil/tatrc/physiology/datamodel");

        // ActivePatientEventData
        //

        ActivePatientEventData::
        ActivePatientEventData ()
        : ::xml_schema::type (),
          Duration_ (this),
          Event_ (this)
        {
        }

        ActivePatientEventData::
        ActivePatientEventData (const Duration_type& Duration,
                                const Event_type& Event)
        : ::xml_schema::type (),
          Duration_ (Duration, this),
          Event_ (Event, this)
        {
        }

        ActivePatientEventData::
        ActivePatientEventData (::std::unique_ptr< Duration_type > Duration,
                                const Event_type& Event)
        : ::xml_schema::type (),
          Duration_ (std::move (Duration), this),
          Event_ (Event, this)
        {
        }

        ActivePatientEventData::
        ActivePatientEventData (const ActivePatientEventData& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
        : ::xml_schema::type (x, f, c),
          Duration_ (x.Duration_, f, this),
          Event_ (x.Event_, f, this)
        {
        }

        ActivePatientEventData::
        ActivePatientEventData (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
        : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
          Duration_ (this),
          Event_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void ActivePatientEventData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Duration
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Duration",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Duration_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!Duration_.present ())
                {
                  ::std::unique_ptr< Duration_type > r (
                    dynamic_cast< Duration_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Duration_.set (::std::move (r));
                  continue;
                }
              }
            }

            break;
          }

          if (!Duration_.present ())
          {
            throw ::xsd::cxx::tree::expected_element< char > (
              "Duration",
              "uri:/mil/tatrc/physiology/datamodel");
          }

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "Event" && n.namespace_ ().empty ())
            {
              this->Event_.set (Event_traits::create (i, f, this));
              continue;
            }
          }

          if (!Event_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "Event",
              "");
          }
        }

        ActivePatientEventData* ActivePatientEventData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class ActivePatientEventData (*this, f, c);
        }

        ActivePatientEventData& ActivePatientEventData::
        operator= (const ActivePatientEventData& x)
        {
          if (this != &x)
          {
            static_cast< ::xml_schema::type& > (*this) = x;
            this->Duration_ = x.Duration_;
            this->Event_ = x.Event_;
          }

          return *this;
        }

        ActivePatientEventData::
        ~ActivePatientEventData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, ActivePatientEventData >
        _xsd_ActivePatientEventData_type_factory_init (
          "ActivePatientEventData",
          "uri:/mil/tatrc/physiology/datamodel");

        // PatientData
        //

        PatientData::
        PatientData ()
        : ::mil::tatrc::physiology::datamodel::ObjectData (),
          Annotation_ (this),
          Name_ (this),
          Sex_ (this),
          Age_ (this),
          Weight_ (this),
          Height_ (this),
          BodyDensity_ (this),
          BodyFatFraction_ (this),
          LeanBodyMass_ (this),
          MaxWorkRate_ (this),
          MuscleMass_ (this),
          BloodTypeABO_ (this),
          BloodTypeRh_ (this),
          AlveoliSurfaceArea_ (this),
          Hyperhidrosis_ (this),
          RightLungRatio_ (this),
          SkinSurfaceArea_ (this),
          SleepAmount_ (this),
          PainSusceptibility_ (this),
          BasalMetabolicRate_ (this),
          BloodVolumeBaseline_ (this),
          DiastolicArterialPressureBaseline_ (this),
          HeartRateBaseline_ (this),
          MeanArterialPressureBaseline_ (this),
          RespirationRateBaseline_ (this),
          SystolicArterialPressureBaseline_ (this),
          TidalVolumeBaseline_ (this),
          HeartRateMaximum_ (this),
          HeartRateMinimum_ (this),
          ExpiratoryReserveVolume_ (this),
          FunctionalResidualCapacity_ (this),
          InspiratoryCapacity_ (this),
          InspiratoryReserveVolume_ (this),
          ResidualVolume_ (this),
          RespiratoryDriverAmplitudeBaseline_ (this),
          TotalLungCapacity_ (this),
          TotalVentilationBaseline_ (this),
          VitalCapacity_ (this),
          ActiveEvent_ (this)
        {
        }

        PatientData::
        PatientData (const Name_type& Name)
        : ::mil::tatrc::physiology::datamodel::ObjectData (),
          Annotation_ (this),
          Name_ (Name, this),
          Sex_ (this),
          Age_ (this),
          Weight_ (this),
          Height_ (this),
          BodyDensity_ (this),
          BodyFatFraction_ (this),
          LeanBodyMass_ (this),
          MaxWorkRate_ (this),
          MuscleMass_ (this),
          BloodTypeABO_ (this),
          BloodTypeRh_ (this),
          AlveoliSurfaceArea_ (this),
          Hyperhidrosis_ (this),
          RightLungRatio_ (this),
          SkinSurfaceArea_ (this),
          SleepAmount_ (this),
          PainSusceptibility_ (this),
          BasalMetabolicRate_ (this),
          BloodVolumeBaseline_ (this),
          DiastolicArterialPressureBaseline_ (this),
          HeartRateBaseline_ (this),
          MeanArterialPressureBaseline_ (this),
          RespirationRateBaseline_ (this),
          SystolicArterialPressureBaseline_ (this),
          TidalVolumeBaseline_ (this),
          HeartRateMaximum_ (this),
          HeartRateMinimum_ (this),
          ExpiratoryReserveVolume_ (this),
          FunctionalResidualCapacity_ (this),
          InspiratoryCapacity_ (this),
          InspiratoryReserveVolume_ (this),
          ResidualVolume_ (this),
          RespiratoryDriverAmplitudeBaseline_ (this),
          TotalLungCapacity_ (this),
          TotalVentilationBaseline_ (this),
          VitalCapacity_ (this),
          ActiveEvent_ (this)
        {
        }

        PatientData::
        PatientData (::std::unique_ptr< Name_type > Name)
        : ::mil::tatrc::physiology::datamodel::ObjectData (),
          Annotation_ (this),
          Name_ (std::move (Name), this),
          Sex_ (this),
          Age_ (this),
          Weight_ (this),
          Height_ (this),
          BodyDensity_ (this),
          BodyFatFraction_ (this),
          LeanBodyMass_ (this),
          MaxWorkRate_ (this),
          MuscleMass_ (this),
          BloodTypeABO_ (this),
          BloodTypeRh_ (this),
          AlveoliSurfaceArea_ (this),
          Hyperhidrosis_ (this),
          RightLungRatio_ (this),
          SkinSurfaceArea_ (this),
          SleepAmount_ (this),
          PainSusceptibility_ (this),
          BasalMetabolicRate_ (this),
          BloodVolumeBaseline_ (this),
          DiastolicArterialPressureBaseline_ (this),
          HeartRateBaseline_ (this),
          MeanArterialPressureBaseline_ (this),
          RespirationRateBaseline_ (this),
          SystolicArterialPressureBaseline_ (this),
          TidalVolumeBaseline_ (this),
          HeartRateMaximum_ (this),
          HeartRateMinimum_ (this),
          ExpiratoryReserveVolume_ (this),
          FunctionalResidualCapacity_ (this),
          InspiratoryCapacity_ (this),
          InspiratoryReserveVolume_ (this),
          ResidualVolume_ (this),
          RespiratoryDriverAmplitudeBaseline_ (this),
          TotalLungCapacity_ (this),
          TotalVentilationBaseline_ (this),
          VitalCapacity_ (this),
          ActiveEvent_ (this)
        {
        }

        PatientData::
        PatientData (const PatientData& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::ObjectData (x, f, c),
          Annotation_ (x.Annotation_, f, this),
          Name_ (x.Name_, f, this),
          Sex_ (x.Sex_, f, this),
          Age_ (x.Age_, f, this),
          Weight_ (x.Weight_, f, this),
          Height_ (x.Height_, f, this),
          BodyDensity_ (x.BodyDensity_, f, this),
          BodyFatFraction_ (x.BodyFatFraction_, f, this),
          LeanBodyMass_ (x.LeanBodyMass_, f, this),
          MaxWorkRate_ (x.MaxWorkRate_, f, this),
          MuscleMass_ (x.MuscleMass_, f, this),
          BloodTypeABO_ (x.BloodTypeABO_, f, this),
          BloodTypeRh_ (x.BloodTypeRh_, f, this),
          AlveoliSurfaceArea_ (x.AlveoliSurfaceArea_, f, this),
          Hyperhidrosis_ (x.Hyperhidrosis_, f, this),
          RightLungRatio_ (x.RightLungRatio_, f, this),
          SkinSurfaceArea_ (x.SkinSurfaceArea_, f, this),
          SleepAmount_ (x.SleepAmount_, f, this),
          PainSusceptibility_ (x.PainSusceptibility_, f, this),
          BasalMetabolicRate_ (x.BasalMetabolicRate_, f, this),
          BloodVolumeBaseline_ (x.BloodVolumeBaseline_, f, this),
          DiastolicArterialPressureBaseline_ (x.DiastolicArterialPressureBaseline_, f, this),
          HeartRateBaseline_ (x.HeartRateBaseline_, f, this),
          MeanArterialPressureBaseline_ (x.MeanArterialPressureBaseline_, f, this),
          RespirationRateBaseline_ (x.RespirationRateBaseline_, f, this),
          SystolicArterialPressureBaseline_ (x.SystolicArterialPressureBaseline_, f, this),
          TidalVolumeBaseline_ (x.TidalVolumeBaseline_, f, this),
          HeartRateMaximum_ (x.HeartRateMaximum_, f, this),
          HeartRateMinimum_ (x.HeartRateMinimum_, f, this),
          ExpiratoryReserveVolume_ (x.ExpiratoryReserveVolume_, f, this),
          FunctionalResidualCapacity_ (x.FunctionalResidualCapacity_, f, this),
          InspiratoryCapacity_ (x.InspiratoryCapacity_, f, this),
          InspiratoryReserveVolume_ (x.InspiratoryReserveVolume_, f, this),
          ResidualVolume_ (x.ResidualVolume_, f, this),
          RespiratoryDriverAmplitudeBaseline_ (x.RespiratoryDriverAmplitudeBaseline_, f, this),
          TotalLungCapacity_ (x.TotalLungCapacity_, f, this),
          TotalVentilationBaseline_ (x.TotalVentilationBaseline_, f, this),
          VitalCapacity_ (x.VitalCapacity_, f, this),
          ActiveEvent_ (x.ActiveEvent_, f, this)
        {
        }

        PatientData::
        PatientData (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
        : ::mil::tatrc::physiology::datamodel::ObjectData (e, f | ::xml_schema::flags::base, c),
          Annotation_ (this),
          Name_ (this),
          Sex_ (this),
          Age_ (this),
          Weight_ (this),
          Height_ (this),
          BodyDensity_ (this),
          BodyFatFraction_ (this),
          LeanBodyMass_ (this),
          MaxWorkRate_ (this),
          MuscleMass_ (this),
          BloodTypeABO_ (this),
          BloodTypeRh_ (this),
          AlveoliSurfaceArea_ (this),
          Hyperhidrosis_ (this),
          RightLungRatio_ (this),
          SkinSurfaceArea_ (this),
          SleepAmount_ (this),
          PainSusceptibility_ (this),
          BasalMetabolicRate_ (this),
          BloodVolumeBaseline_ (this),
          DiastolicArterialPressureBaseline_ (this),
          HeartRateBaseline_ (this),
          MeanArterialPressureBaseline_ (this),
          RespirationRateBaseline_ (this),
          SystolicArterialPressureBaseline_ (this),
          TidalVolumeBaseline_ (this),
          HeartRateMaximum_ (this),
          HeartRateMinimum_ (this),
          ExpiratoryReserveVolume_ (this),
          FunctionalResidualCapacity_ (this),
          InspiratoryCapacity_ (this),
          InspiratoryReserveVolume_ (this),
          ResidualVolume_ (this),
          RespiratoryDriverAmplitudeBaseline_ (this),
          TotalLungCapacity_ (this),
          TotalVentilationBaseline_ (this),
          VitalCapacity_ (this),
          ActiveEvent_ (this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
            this->parse (p, f);
          }
        }

        void PatientData::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::mil::tatrc::physiology::datamodel::ObjectData::parse (p, f);

          for (; p.more_content (); p.next_content (false))
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // Annotation
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Annotation",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Annotation_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Annotation_)
                {
                  ::std::unique_ptr< Annotation_type > r (
                    dynamic_cast< Annotation_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Annotation_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Name
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Name",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Name_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!Name_.present ())
                {
                  ::std::unique_ptr< Name_type > r (
                    dynamic_cast< Name_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Name_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Sex
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Sex",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Sex_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Sex_)
                {
                  ::std::unique_ptr< Sex_type > r (
                    dynamic_cast< Sex_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Sex_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Age
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Age",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Age_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Age_)
                {
                  ::std::unique_ptr< Age_type > r (
                    dynamic_cast< Age_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Age_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Weight
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Weight",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Weight_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Weight_)
                {
                  ::std::unique_ptr< Weight_type > r (
                    dynamic_cast< Weight_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Weight_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Height
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Height",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Height_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Height_)
                {
                  ::std::unique_ptr< Height_type > r (
                    dynamic_cast< Height_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Height_.set (::std::move (r));
                  continue;
                }
              }
            }

            // BodyDensity
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "BodyDensity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< BodyDensity_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->BodyDensity_)
                {
                  ::std::unique_ptr< BodyDensity_type > r (
                    dynamic_cast< BodyDensity_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->BodyDensity_.set (::std::move (r));
                  continue;
                }
              }
            }

            // BodyFatFraction
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "BodyFatFraction",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< BodyFatFraction_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->BodyFatFraction_)
                {
                  ::std::unique_ptr< BodyFatFraction_type > r (
                    dynamic_cast< BodyFatFraction_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->BodyFatFraction_.set (::std::move (r));
                  continue;
                }
              }
            }

            // LeanBodyMass
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "LeanBodyMass",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< LeanBodyMass_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->LeanBodyMass_)
                {
                  ::std::unique_ptr< LeanBodyMass_type > r (
                    dynamic_cast< LeanBodyMass_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->LeanBodyMass_.set (::std::move (r));
                  continue;
                }
              }
            }

            // MaxWorkRate
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "MaxWorkRate",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< MaxWorkRate_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->MaxWorkRate_)
                {
                  ::std::unique_ptr< MaxWorkRate_type > r (
                    dynamic_cast< MaxWorkRate_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->MaxWorkRate_.set (::std::move (r));
                  continue;
                }
              }
            }

            // MuscleMass
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "MuscleMass",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< MuscleMass_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->MuscleMass_)
                {
                  ::std::unique_ptr< MuscleMass_type > r (
                    dynamic_cast< MuscleMass_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->MuscleMass_.set (::std::move (r));
                  continue;
                }
              }
            }

            // BloodTypeABO
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "BloodTypeABO",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< BloodTypeABO_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->BloodTypeABO_)
                {
                  ::std::unique_ptr< BloodTypeABO_type > r (
                    dynamic_cast< BloodTypeABO_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->BloodTypeABO_.set (::std::move (r));
                  continue;
                }
              }
            }

            // BloodTypeRh
            //
            if (n.name () == "BloodTypeRh" && n.namespace_ () == "uri:/mil/tatrc/physiology/datamodel")
            {
              if (!this->BloodTypeRh_)
              {
                this->BloodTypeRh_.set (BloodTypeRh_traits::create (i, f, this));
                continue;
              }
            }

            // AlveoliSurfaceArea
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "AlveoliSurfaceArea",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< AlveoliSurfaceArea_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->AlveoliSurfaceArea_)
                {
                  ::std::unique_ptr< AlveoliSurfaceArea_type > r (
                    dynamic_cast< AlveoliSurfaceArea_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->AlveoliSurfaceArea_.set (::std::move (r));
                  continue;
                }
              }
            }

            // Hyperhidrosis
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "Hyperhidrosis",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< Hyperhidrosis_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->Hyperhidrosis_)
                {
                  ::std::unique_ptr< Hyperhidrosis_type > r (
                    dynamic_cast< Hyperhidrosis_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->Hyperhidrosis_.set (::std::move (r));
                  continue;
                }
              }
            }

            // RightLungRatio
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "RightLungRatio",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< RightLungRatio_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->RightLungRatio_)
                {
                  ::std::unique_ptr< RightLungRatio_type > r (
                    dynamic_cast< RightLungRatio_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->RightLungRatio_.set (::std::move (r));
                  continue;
                }
              }
            }

            // SkinSurfaceArea
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "SkinSurfaceArea",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< SkinSurfaceArea_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->SkinSurfaceArea_)
                {
                  ::std::unique_ptr< SkinSurfaceArea_type > r (
                    dynamic_cast< SkinSurfaceArea_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->SkinSurfaceArea_.set (::std::move (r));
                  continue;
                }
              }
            }

            // SleepAmount
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "SleepAmount",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< SleepAmount_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->SleepAmount_)
                {
                  ::std::unique_ptr< SleepAmount_type > r (
                    dynamic_cast< SleepAmount_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->SleepAmount_.set (::std::move (r));
                  continue;
                }
              }
            }

            // PainSusceptibility
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "PainSusceptibility",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< PainSusceptibility_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->PainSusceptibility_)
                {
                  ::std::unique_ptr< PainSusceptibility_type > r (
                    dynamic_cast< PainSusceptibility_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->PainSusceptibility_.set (::std::move (r));
                  continue;
                }
              }
            }

            // BasalMetabolicRate
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "BasalMetabolicRate",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< BasalMetabolicRate_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->BasalMetabolicRate_)
                {
                  ::std::unique_ptr< BasalMetabolicRate_type > r (
                    dynamic_cast< BasalMetabolicRate_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->BasalMetabolicRate_.set (::std::move (r));
                  continue;
                }
              }
            }

            // BloodVolumeBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "BloodVolumeBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< BloodVolumeBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->BloodVolumeBaseline_)
                {
                  ::std::unique_ptr< BloodVolumeBaseline_type > r (
                    dynamic_cast< BloodVolumeBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->BloodVolumeBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // DiastolicArterialPressureBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "DiastolicArterialPressureBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< DiastolicArterialPressureBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->DiastolicArterialPressureBaseline_)
                {
                  ::std::unique_ptr< DiastolicArterialPressureBaseline_type > r (
                    dynamic_cast< DiastolicArterialPressureBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->DiastolicArterialPressureBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // HeartRateBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "HeartRateBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< HeartRateBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->HeartRateBaseline_)
                {
                  ::std::unique_ptr< HeartRateBaseline_type > r (
                    dynamic_cast< HeartRateBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->HeartRateBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // MeanArterialPressureBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "MeanArterialPressureBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< MeanArterialPressureBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->MeanArterialPressureBaseline_)
                {
                  ::std::unique_ptr< MeanArterialPressureBaseline_type > r (
                    dynamic_cast< MeanArterialPressureBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->MeanArterialPressureBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // RespirationRateBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "RespirationRateBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< RespirationRateBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->RespirationRateBaseline_)
                {
                  ::std::unique_ptr< RespirationRateBaseline_type > r (
                    dynamic_cast< RespirationRateBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->RespirationRateBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // SystolicArterialPressureBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "SystolicArterialPressureBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< SystolicArterialPressureBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->SystolicArterialPressureBaseline_)
                {
                  ::std::unique_ptr< SystolicArterialPressureBaseline_type > r (
                    dynamic_cast< SystolicArterialPressureBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->SystolicArterialPressureBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // TidalVolumeBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "TidalVolumeBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< TidalVolumeBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->TidalVolumeBaseline_)
                {
                  ::std::unique_ptr< TidalVolumeBaseline_type > r (
                    dynamic_cast< TidalVolumeBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->TidalVolumeBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // HeartRateMaximum
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "HeartRateMaximum",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< HeartRateMaximum_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->HeartRateMaximum_)
                {
                  ::std::unique_ptr< HeartRateMaximum_type > r (
                    dynamic_cast< HeartRateMaximum_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->HeartRateMaximum_.set (::std::move (r));
                  continue;
                }
              }
            }

            // HeartRateMinimum
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "HeartRateMinimum",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< HeartRateMinimum_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->HeartRateMinimum_)
                {
                  ::std::unique_ptr< HeartRateMinimum_type > r (
                    dynamic_cast< HeartRateMinimum_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->HeartRateMinimum_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ExpiratoryReserveVolume
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ExpiratoryReserveVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ExpiratoryReserveVolume_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ExpiratoryReserveVolume_)
                {
                  ::std::unique_ptr< ExpiratoryReserveVolume_type > r (
                    dynamic_cast< ExpiratoryReserveVolume_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ExpiratoryReserveVolume_.set (::std::move (r));
                  continue;
                }
              }
            }

            // FunctionalResidualCapacity
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "FunctionalResidualCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< FunctionalResidualCapacity_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->FunctionalResidualCapacity_)
                {
                  ::std::unique_ptr< FunctionalResidualCapacity_type > r (
                    dynamic_cast< FunctionalResidualCapacity_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->FunctionalResidualCapacity_.set (::std::move (r));
                  continue;
                }
              }
            }

            // InspiratoryCapacity
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "InspiratoryCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< InspiratoryCapacity_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->InspiratoryCapacity_)
                {
                  ::std::unique_ptr< InspiratoryCapacity_type > r (
                    dynamic_cast< InspiratoryCapacity_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->InspiratoryCapacity_.set (::std::move (r));
                  continue;
                }
              }
            }

            // InspiratoryReserveVolume
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "InspiratoryReserveVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< InspiratoryReserveVolume_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->InspiratoryReserveVolume_)
                {
                  ::std::unique_ptr< InspiratoryReserveVolume_type > r (
                    dynamic_cast< InspiratoryReserveVolume_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->InspiratoryReserveVolume_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ResidualVolume
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ResidualVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ResidualVolume_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->ResidualVolume_)
                {
                  ::std::unique_ptr< ResidualVolume_type > r (
                    dynamic_cast< ResidualVolume_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->ResidualVolume_.set (::std::move (r));
                  continue;
                }
              }
            }

            // RespiratoryDriverAmplitudeBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "RespiratoryDriverAmplitudeBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< RespiratoryDriverAmplitudeBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->RespiratoryDriverAmplitudeBaseline_)
                {
                  ::std::unique_ptr< RespiratoryDriverAmplitudeBaseline_type > r (
                    dynamic_cast< RespiratoryDriverAmplitudeBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->RespiratoryDriverAmplitudeBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // TotalLungCapacity
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "TotalLungCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< TotalLungCapacity_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->TotalLungCapacity_)
                {
                  ::std::unique_ptr< TotalLungCapacity_type > r (
                    dynamic_cast< TotalLungCapacity_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->TotalLungCapacity_.set (::std::move (r));
                  continue;
                }
              }
            }

            // TotalVentilationBaseline
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "TotalVentilationBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< TotalVentilationBaseline_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->TotalVentilationBaseline_)
                {
                  ::std::unique_ptr< TotalVentilationBaseline_type > r (
                    dynamic_cast< TotalVentilationBaseline_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->TotalVentilationBaseline_.set (::std::move (r));
                  continue;
                }
              }
            }

            // VitalCapacity
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "VitalCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< VitalCapacity_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->VitalCapacity_)
                {
                  ::std::unique_ptr< VitalCapacity_type > r (
                    dynamic_cast< VitalCapacity_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->VitalCapacity_.set (::std::move (r));
                  continue;
                }
              }
            }

            // ActiveEvent
            //
            {
              ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                  "ActiveEvent",
                  "uri:/mil/tatrc/physiology/datamodel",
                  &::xsd::cxx::tree::factory_impl< ActiveEvent_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::unique_ptr< ActiveEvent_type > r (
                  dynamic_cast< ActiveEvent_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->ActiveEvent_.push_back (::std::move (r));
                continue;
              }
            }

            break;
          }

          if (!Name_.present ())
          {
            throw ::xsd::cxx::tree::expected_element< char > (
              "Name",
              "uri:/mil/tatrc/physiology/datamodel");
          }
        }

        PatientData* PatientData::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class PatientData (*this, f, c);
        }

        PatientData& PatientData::
        operator= (const PatientData& x)
        {
          if (this != &x)
          {
            static_cast< ::mil::tatrc::physiology::datamodel::ObjectData& > (*this) = x;
            this->Annotation_ = x.Annotation_;
            this->Name_ = x.Name_;
            this->Sex_ = x.Sex_;
            this->Age_ = x.Age_;
            this->Weight_ = x.Weight_;
            this->Height_ = x.Height_;
            this->BodyDensity_ = x.BodyDensity_;
            this->BodyFatFraction_ = x.BodyFatFraction_;
            this->LeanBodyMass_ = x.LeanBodyMass_;
            this->MaxWorkRate_ = x.MaxWorkRate_;
            this->MuscleMass_ = x.MuscleMass_;
            this->BloodTypeABO_ = x.BloodTypeABO_;
            this->BloodTypeRh_ = x.BloodTypeRh_;
            this->AlveoliSurfaceArea_ = x.AlveoliSurfaceArea_;
            this->Hyperhidrosis_ = x.Hyperhidrosis_;
            this->RightLungRatio_ = x.RightLungRatio_;
            this->SkinSurfaceArea_ = x.SkinSurfaceArea_;
            this->SleepAmount_ = x.SleepAmount_;
            this->PainSusceptibility_ = x.PainSusceptibility_;
            this->BasalMetabolicRate_ = x.BasalMetabolicRate_;
            this->BloodVolumeBaseline_ = x.BloodVolumeBaseline_;
            this->DiastolicArterialPressureBaseline_ = x.DiastolicArterialPressureBaseline_;
            this->HeartRateBaseline_ = x.HeartRateBaseline_;
            this->MeanArterialPressureBaseline_ = x.MeanArterialPressureBaseline_;
            this->RespirationRateBaseline_ = x.RespirationRateBaseline_;
            this->SystolicArterialPressureBaseline_ = x.SystolicArterialPressureBaseline_;
            this->TidalVolumeBaseline_ = x.TidalVolumeBaseline_;
            this->HeartRateMaximum_ = x.HeartRateMaximum_;
            this->HeartRateMinimum_ = x.HeartRateMinimum_;
            this->ExpiratoryReserveVolume_ = x.ExpiratoryReserveVolume_;
            this->FunctionalResidualCapacity_ = x.FunctionalResidualCapacity_;
            this->InspiratoryCapacity_ = x.InspiratoryCapacity_;
            this->InspiratoryReserveVolume_ = x.InspiratoryReserveVolume_;
            this->ResidualVolume_ = x.ResidualVolume_;
            this->RespiratoryDriverAmplitudeBaseline_ = x.RespiratoryDriverAmplitudeBaseline_;
            this->TotalLungCapacity_ = x.TotalLungCapacity_;
            this->TotalVentilationBaseline_ = x.TotalVentilationBaseline_;
            this->VitalCapacity_ = x.VitalCapacity_;
            this->ActiveEvent_ = x.ActiveEvent_;
          }

          return *this;
        }

        PatientData::
        ~PatientData ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, PatientData >
        _xsd_PatientData_type_factory_init (
          "PatientData",
          "uri:/mil/tatrc/physiology/datamodel");
      }
    }
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        ::std::ostream&
        operator<< (::std::ostream& o, enumSex::value i)
        {
          return o << enumSex::_xsd_enumSex_literals_[i];
        }

        ::std::ostream&
        operator<< (::std::ostream& o, const enumSex& i)
        {
          return o << static_cast< const ::xml_schema::string& > (i);
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, enumSex >
        _xsd_enumSex_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, enumBloodType::value i)
        {
          return o << enumBloodType::_xsd_enumBloodType_literals_[i];
        }

        ::std::ostream&
        operator<< (::std::ostream& o, const enumBloodType& i)
        {
          return o << static_cast< const ::xml_schema::string& > (i);
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, enumBloodType >
        _xsd_enumBloodType_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, enumPatientEvent::value i)
        {
          return o << enumPatientEvent::_xsd_enumPatientEvent_literals_[i];
        }

        ::std::ostream&
        operator<< (::std::ostream& o, const enumPatientEvent& i)
        {
          return o << static_cast< const ::xml_schema::string& > (i);
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, enumPatientEvent >
        _xsd_enumPatientEvent_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, const ActivePatientEventData& i)
        {
          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            o << ::std::endl << "Duration: ";
            om.insert (o, i.Duration ());
          }

          o << ::std::endl << "Event: " << i.Event ();
          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ActivePatientEventData >
        _xsd_ActivePatientEventData_std_ostream_init;

        ::std::ostream&
        operator<< (::std::ostream& o, const PatientData& i)
        {
          o << static_cast< const ::mil::tatrc::physiology::datamodel::ObjectData& > (i);

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Annotation ())
            {
              o << ::std::endl << "Annotation: ";
              om.insert (o, *i.Annotation ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            o << ::std::endl << "Name: ";
            om.insert (o, i.Name ());
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Sex ())
            {
              o << ::std::endl << "Sex: ";
              om.insert (o, *i.Sex ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Age ())
            {
              o << ::std::endl << "Age: ";
              om.insert (o, *i.Age ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Weight ())
            {
              o << ::std::endl << "Weight: ";
              om.insert (o, *i.Weight ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Height ())
            {
              o << ::std::endl << "Height: ";
              om.insert (o, *i.Height ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.BodyDensity ())
            {
              o << ::std::endl << "BodyDensity: ";
              om.insert (o, *i.BodyDensity ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.BodyFatFraction ())
            {
              o << ::std::endl << "BodyFatFraction: ";
              om.insert (o, *i.BodyFatFraction ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.LeanBodyMass ())
            {
              o << ::std::endl << "LeanBodyMass: ";
              om.insert (o, *i.LeanBodyMass ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.MaxWorkRate ())
            {
              o << ::std::endl << "MaxWorkRate: ";
              om.insert (o, *i.MaxWorkRate ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.MuscleMass ())
            {
              o << ::std::endl << "MuscleMass: ";
              om.insert (o, *i.MuscleMass ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.BloodTypeABO ())
            {
              o << ::std::endl << "BloodTypeABO: ";
              om.insert (o, *i.BloodTypeABO ());
            }
          }

          if (i.BloodTypeRh ())
          {
            o << ::std::endl << "BloodTypeRh: " << *i.BloodTypeRh ();
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.AlveoliSurfaceArea ())
            {
              o << ::std::endl << "AlveoliSurfaceArea: ";
              om.insert (o, *i.AlveoliSurfaceArea ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.Hyperhidrosis ())
            {
              o << ::std::endl << "Hyperhidrosis: ";
              om.insert (o, *i.Hyperhidrosis ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.RightLungRatio ())
            {
              o << ::std::endl << "RightLungRatio: ";
              om.insert (o, *i.RightLungRatio ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.SkinSurfaceArea ())
            {
              o << ::std::endl << "SkinSurfaceArea: ";
              om.insert (o, *i.SkinSurfaceArea ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.SleepAmount ())
            {
              o << ::std::endl << "SleepAmount: ";
              om.insert (o, *i.SleepAmount ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.PainSusceptibility ())
            {
              o << ::std::endl << "PainSusceptibility: ";
              om.insert (o, *i.PainSusceptibility ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.BasalMetabolicRate ())
            {
              o << ::std::endl << "BasalMetabolicRate: ";
              om.insert (o, *i.BasalMetabolicRate ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.BloodVolumeBaseline ())
            {
              o << ::std::endl << "BloodVolumeBaseline: ";
              om.insert (o, *i.BloodVolumeBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.DiastolicArterialPressureBaseline ())
            {
              o << ::std::endl << "DiastolicArterialPressureBaseline: ";
              om.insert (o, *i.DiastolicArterialPressureBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.HeartRateBaseline ())
            {
              o << ::std::endl << "HeartRateBaseline: ";
              om.insert (o, *i.HeartRateBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.MeanArterialPressureBaseline ())
            {
              o << ::std::endl << "MeanArterialPressureBaseline: ";
              om.insert (o, *i.MeanArterialPressureBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.RespirationRateBaseline ())
            {
              o << ::std::endl << "RespirationRateBaseline: ";
              om.insert (o, *i.RespirationRateBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.SystolicArterialPressureBaseline ())
            {
              o << ::std::endl << "SystolicArterialPressureBaseline: ";
              om.insert (o, *i.SystolicArterialPressureBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.TidalVolumeBaseline ())
            {
              o << ::std::endl << "TidalVolumeBaseline: ";
              om.insert (o, *i.TidalVolumeBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.HeartRateMaximum ())
            {
              o << ::std::endl << "HeartRateMaximum: ";
              om.insert (o, *i.HeartRateMaximum ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.HeartRateMinimum ())
            {
              o << ::std::endl << "HeartRateMinimum: ";
              om.insert (o, *i.HeartRateMinimum ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ExpiratoryReserveVolume ())
            {
              o << ::std::endl << "ExpiratoryReserveVolume: ";
              om.insert (o, *i.ExpiratoryReserveVolume ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.FunctionalResidualCapacity ())
            {
              o << ::std::endl << "FunctionalResidualCapacity: ";
              om.insert (o, *i.FunctionalResidualCapacity ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.InspiratoryCapacity ())
            {
              o << ::std::endl << "InspiratoryCapacity: ";
              om.insert (o, *i.InspiratoryCapacity ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.InspiratoryReserveVolume ())
            {
              o << ::std::endl << "InspiratoryReserveVolume: ";
              om.insert (o, *i.InspiratoryReserveVolume ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.ResidualVolume ())
            {
              o << ::std::endl << "ResidualVolume: ";
              om.insert (o, *i.ResidualVolume ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.RespiratoryDriverAmplitudeBaseline ())
            {
              o << ::std::endl << "RespiratoryDriverAmplitudeBaseline: ";
              om.insert (o, *i.RespiratoryDriverAmplitudeBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.TotalLungCapacity ())
            {
              o << ::std::endl << "TotalLungCapacity: ";
              om.insert (o, *i.TotalLungCapacity ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.TotalVentilationBaseline ())
            {
              o << ::std::endl << "TotalVentilationBaseline: ";
              om.insert (o, *i.TotalVentilationBaseline ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            if (i.VitalCapacity ())
            {
              o << ::std::endl << "VitalCapacity: ";
              om.insert (o, *i.VitalCapacity ());
            }
          }

          {
            ::xsd::cxx::tree::std_ostream_map< char >& om (
              ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

            for (PatientData::ActiveEvent_const_iterator
                 b (i.ActiveEvent ().begin ()), e (i.ActiveEvent ().end ());
                 b != e; ++b)
            {
              o << ::std::endl << "ActiveEvent: ";
              om.insert (o, *b);
            }
          }

          return o;
        }

        static
        const ::xsd::cxx::tree::std_ostream_initializer< 0, char, PatientData >
        _xsd_PatientData_std_ostream_init;
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData >
        Patient (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0,
            (f & ::xml_schema::flags::keep_dom) == 0);

          ::xsd::cxx::tree::error_handler< char > h;

          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::xsd::cxx::xml::dom::parse< char > (
              u, h, p, f));

          h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

          return ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData > (
            ::mil::tatrc::physiology::datamodel::Patient (
              std::move (d), f | ::xml_schema::flags::own_dom, p));
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData >
        Patient (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0,
            (f & ::xml_schema::flags::keep_dom) == 0);

          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::xsd::cxx::xml::dom::parse< char > (
              u, h, p, f));

          if (!d.get ())
            throw ::xsd::cxx::tree::parsing< char > ();

          return ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData > (
            ::mil::tatrc::physiology::datamodel::Patient (
              std::move (d), f | ::xml_schema::flags::own_dom, p));
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData >
        Patient (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::xsd::cxx::xml::dom::parse< char > (
              u, h, p, f));

          if (!d.get ())
            throw ::xsd::cxx::tree::parsing< char > ();

          return ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData > (
            ::mil::tatrc::physiology::datamodel::Patient (
              std::move (d), f | ::xml_schema::flags::own_dom, p));
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData >
        Patient (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0,
            (f & ::xml_schema::flags::keep_dom) == 0);

          ::xsd::cxx::xml::sax::std_input_source isrc (is);
          return ::mil::tatrc::physiology::datamodel::Patient (isrc, f, p);
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData >
        Patient (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0,
            (f & ::xml_schema::flags::keep_dom) == 0);

          ::xsd::cxx::xml::sax::std_input_source isrc (is);
          return ::mil::tatrc::physiology::datamodel::Patient (isrc, h, f, p);
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData >
        Patient (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::sax::std_input_source isrc (is);
          return ::mil::tatrc::physiology::datamodel::Patient (isrc, h, f, p);
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData >
        Patient (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0,
            (f & ::xml_schema::flags::keep_dom) == 0);

          ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
          return ::mil::tatrc::physiology::datamodel::Patient (isrc, f, p);
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData >
        Patient (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0,
            (f & ::xml_schema::flags::keep_dom) == 0);

          ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
          return ::mil::tatrc::physiology::datamodel::Patient (isrc, h, f, p);
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData >
        Patient (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
        {
          ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
          return ::mil::tatrc::physiology::datamodel::Patient (isrc, h, f, p);
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData >
        Patient (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
        {
          ::xsd::cxx::tree::error_handler< char > h;

          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::xsd::cxx::xml::dom::parse< char > (
              i, h, p, f));

          h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

          return ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData > (
            ::mil::tatrc::physiology::datamodel::Patient (
              std::move (d), f | ::xml_schema::flags::own_dom, p));
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData >
        Patient (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::xsd::cxx::xml::dom::parse< char > (
              i, h, p, f));

          if (!d.get ())
            throw ::xsd::cxx::tree::parsing< char > ();

          return ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData > (
            ::mil::tatrc::physiology::datamodel::Patient (
              std::move (d), f | ::xml_schema::flags::own_dom, p));
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData >
        Patient (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::xsd::cxx::xml::dom::parse< char > (
              i, h, p, f));

          if (!d.get ())
            throw ::xsd::cxx::tree::parsing< char > ();

          return ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData > (
            ::mil::tatrc::physiology::datamodel::Patient (
              std::move (d), f | ::xml_schema::flags::own_dom, p));
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData >
        Patient (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
        {
          if (f & ::xml_schema::flags::keep_dom)
          {
            ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
              static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

            return ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData > (
              ::mil::tatrc::physiology::datamodel::Patient (
                std::move (d), f | ::xml_schema::flags::own_dom, p));
          }

          const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (e));

          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Patient",
              "uri:/mil/tatrc/physiology/datamodel",
              &::xsd::cxx::tree::factory_impl< ::mil::tatrc::physiology::datamodel::PatientData >,
              true, true, e, n, f, 0));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData > r (
              dynamic_cast< ::mil::tatrc::physiology::datamodel::PatientData* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            return r;
          }

          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Patient",
            "uri:/mil/tatrc/physiology/datamodel");
        }

        ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData >
        Patient (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
            ((f & ::xml_schema::flags::keep_dom) &&
             !(f & ::xml_schema::flags::own_dom))
            ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
            : 0);

          ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
          const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (e));

          if (f & ::xml_schema::flags::keep_dom)
            doc.setUserData (::xml_schema::dom::tree_node_key,
                             (c.get () ? &c : &d),
                             0);

          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Patient",
              "uri:/mil/tatrc/physiology/datamodel",
              &::xsd::cxx::tree::factory_impl< ::mil::tatrc::physiology::datamodel::PatientData >,
              true, true, e, n, f, 0));

          if (tmp.get () != 0)
          {

            ::std::unique_ptr< ::mil::tatrc::physiology::datamodel::PatientData > r (
              dynamic_cast< ::mil::tatrc::physiology::datamodel::PatientData* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            return r;
          }

          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Patient",
            "uri:/mil/tatrc/physiology/datamodel");
        }
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace mil
{
  namespace tatrc
  {
    namespace physiology
    {
      namespace datamodel
      {
        void
        operator<< (::xercesc::DOMElement& e, const enumSex& i)
        {
          e << static_cast< const ::xml_schema::string& > (i);
        }

        void
        operator<< (::xercesc::DOMAttr& a, const enumSex& i)
        {
          a << static_cast< const ::xml_schema::string& > (i);
        }

        void
        operator<< (::xml_schema::list_stream& l,
                    const enumSex& i)
        {
          l << static_cast< const ::xml_schema::string& > (i);
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, enumSex >
        _xsd_enumSex_type_serializer_init (
          "enumSex",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const enumBloodType& i)
        {
          e << static_cast< const ::xml_schema::string& > (i);
        }

        void
        operator<< (::xercesc::DOMAttr& a, const enumBloodType& i)
        {
          a << static_cast< const ::xml_schema::string& > (i);
        }

        void
        operator<< (::xml_schema::list_stream& l,
                    const enumBloodType& i)
        {
          l << static_cast< const ::xml_schema::string& > (i);
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, enumBloodType >
        _xsd_enumBloodType_type_serializer_init (
          "enumBloodType",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const enumPatientEvent& i)
        {
          e << static_cast< const ::xml_schema::string& > (i);
        }

        void
        operator<< (::xercesc::DOMAttr& a, const enumPatientEvent& i)
        {
          a << static_cast< const ::xml_schema::string& > (i);
        }

        void
        operator<< (::xml_schema::list_stream& l,
                    const enumPatientEvent& i)
        {
          l << static_cast< const ::xml_schema::string& > (i);
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, enumPatientEvent >
        _xsd_enumPatientEvent_type_serializer_init (
          "enumPatientEvent",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const ActivePatientEventData& i)
        {
          e << static_cast< const ::xml_schema::type& > (i);

          // Duration
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            const ActivePatientEventData::Duration_type& x (i.Duration ());
            if (typeid (ActivePatientEventData::Duration_type) == typeid (x))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "Duration",
                  "uri:/mil/tatrc/physiology/datamodel",
                  e));

              s << x;
            }
            else
              tsm.serialize (
                "Duration",
                "uri:/mil/tatrc/physiology/datamodel",
                false, true, e, x);
          }

          // Event
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "Event",
                e));

            a << i.Event ();
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ActivePatientEventData >
        _xsd_ActivePatientEventData_type_serializer_init (
          "ActivePatientEventData",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        operator<< (::xercesc::DOMElement& e, const PatientData& i)
        {
          e << static_cast< const ::mil::tatrc::physiology::datamodel::ObjectData& > (i);

          // Annotation
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Annotation ())
            {
              const PatientData::Annotation_type& x (*i.Annotation ());
              if (typeid (PatientData::Annotation_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Annotation",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Annotation",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Name
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            const PatientData::Name_type& x (i.Name ());
            if (typeid (PatientData::Name_type) == typeid (x))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "Name",
                  "uri:/mil/tatrc/physiology/datamodel",
                  e));

              s << x;
            }
            else
              tsm.serialize (
                "Name",
                "uri:/mil/tatrc/physiology/datamodel",
                false, true, e, x);
          }

          // Sex
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Sex ())
            {
              const PatientData::Sex_type& x (*i.Sex ());
              if (typeid (PatientData::Sex_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Sex",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Sex",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Age
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Age ())
            {
              const PatientData::Age_type& x (*i.Age ());
              if (typeid (PatientData::Age_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Age",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Age",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Weight
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Weight ())
            {
              const PatientData::Weight_type& x (*i.Weight ());
              if (typeid (PatientData::Weight_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Weight",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Weight",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Height
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Height ())
            {
              const PatientData::Height_type& x (*i.Height ());
              if (typeid (PatientData::Height_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Height",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Height",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // BodyDensity
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.BodyDensity ())
            {
              const PatientData::BodyDensity_type& x (*i.BodyDensity ());
              if (typeid (PatientData::BodyDensity_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "BodyDensity",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "BodyDensity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // BodyFatFraction
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.BodyFatFraction ())
            {
              const PatientData::BodyFatFraction_type& x (*i.BodyFatFraction ());
              if (typeid (PatientData::BodyFatFraction_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "BodyFatFraction",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "BodyFatFraction",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // LeanBodyMass
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.LeanBodyMass ())
            {
              const PatientData::LeanBodyMass_type& x (*i.LeanBodyMass ());
              if (typeid (PatientData::LeanBodyMass_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "LeanBodyMass",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "LeanBodyMass",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // MaxWorkRate
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.MaxWorkRate ())
            {
              const PatientData::MaxWorkRate_type& x (*i.MaxWorkRate ());
              if (typeid (PatientData::MaxWorkRate_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "MaxWorkRate",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "MaxWorkRate",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // MuscleMass
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.MuscleMass ())
            {
              const PatientData::MuscleMass_type& x (*i.MuscleMass ());
              if (typeid (PatientData::MuscleMass_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "MuscleMass",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "MuscleMass",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // BloodTypeABO
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.BloodTypeABO ())
            {
              const PatientData::BloodTypeABO_type& x (*i.BloodTypeABO ());
              if (typeid (PatientData::BloodTypeABO_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "BloodTypeABO",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "BloodTypeABO",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // BloodTypeRh
          //
          if (i.BloodTypeRh ())
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "BloodTypeRh",
                "uri:/mil/tatrc/physiology/datamodel",
                e));

            s << *i.BloodTypeRh ();
          }

          // AlveoliSurfaceArea
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.AlveoliSurfaceArea ())
            {
              const PatientData::AlveoliSurfaceArea_type& x (*i.AlveoliSurfaceArea ());
              if (typeid (PatientData::AlveoliSurfaceArea_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "AlveoliSurfaceArea",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "AlveoliSurfaceArea",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // Hyperhidrosis
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.Hyperhidrosis ())
            {
              const PatientData::Hyperhidrosis_type& x (*i.Hyperhidrosis ());
              if (typeid (PatientData::Hyperhidrosis_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "Hyperhidrosis",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "Hyperhidrosis",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // RightLungRatio
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.RightLungRatio ())
            {
              const PatientData::RightLungRatio_type& x (*i.RightLungRatio ());
              if (typeid (PatientData::RightLungRatio_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "RightLungRatio",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "RightLungRatio",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // SkinSurfaceArea
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.SkinSurfaceArea ())
            {
              const PatientData::SkinSurfaceArea_type& x (*i.SkinSurfaceArea ());
              if (typeid (PatientData::SkinSurfaceArea_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "SkinSurfaceArea",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "SkinSurfaceArea",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // SleepAmount
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.SleepAmount ())
            {
              const PatientData::SleepAmount_type& x (*i.SleepAmount ());
              if (typeid (PatientData::SleepAmount_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "SleepAmount",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "SleepAmount",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // PainSusceptibility
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.PainSusceptibility ())
            {
              const PatientData::PainSusceptibility_type& x (*i.PainSusceptibility ());
              if (typeid (PatientData::PainSusceptibility_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "PainSusceptibility",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "PainSusceptibility",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // BasalMetabolicRate
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.BasalMetabolicRate ())
            {
              const PatientData::BasalMetabolicRate_type& x (*i.BasalMetabolicRate ());
              if (typeid (PatientData::BasalMetabolicRate_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "BasalMetabolicRate",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "BasalMetabolicRate",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // BloodVolumeBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.BloodVolumeBaseline ())
            {
              const PatientData::BloodVolumeBaseline_type& x (*i.BloodVolumeBaseline ());
              if (typeid (PatientData::BloodVolumeBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "BloodVolumeBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "BloodVolumeBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // DiastolicArterialPressureBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.DiastolicArterialPressureBaseline ())
            {
              const PatientData::DiastolicArterialPressureBaseline_type& x (*i.DiastolicArterialPressureBaseline ());
              if (typeid (PatientData::DiastolicArterialPressureBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "DiastolicArterialPressureBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "DiastolicArterialPressureBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // HeartRateBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.HeartRateBaseline ())
            {
              const PatientData::HeartRateBaseline_type& x (*i.HeartRateBaseline ());
              if (typeid (PatientData::HeartRateBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "HeartRateBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "HeartRateBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // MeanArterialPressureBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.MeanArterialPressureBaseline ())
            {
              const PatientData::MeanArterialPressureBaseline_type& x (*i.MeanArterialPressureBaseline ());
              if (typeid (PatientData::MeanArterialPressureBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "MeanArterialPressureBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "MeanArterialPressureBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // RespirationRateBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.RespirationRateBaseline ())
            {
              const PatientData::RespirationRateBaseline_type& x (*i.RespirationRateBaseline ());
              if (typeid (PatientData::RespirationRateBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "RespirationRateBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "RespirationRateBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // SystolicArterialPressureBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.SystolicArterialPressureBaseline ())
            {
              const PatientData::SystolicArterialPressureBaseline_type& x (*i.SystolicArterialPressureBaseline ());
              if (typeid (PatientData::SystolicArterialPressureBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "SystolicArterialPressureBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "SystolicArterialPressureBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // TidalVolumeBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.TidalVolumeBaseline ())
            {
              const PatientData::TidalVolumeBaseline_type& x (*i.TidalVolumeBaseline ());
              if (typeid (PatientData::TidalVolumeBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "TidalVolumeBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "TidalVolumeBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // HeartRateMaximum
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.HeartRateMaximum ())
            {
              const PatientData::HeartRateMaximum_type& x (*i.HeartRateMaximum ());
              if (typeid (PatientData::HeartRateMaximum_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "HeartRateMaximum",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "HeartRateMaximum",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // HeartRateMinimum
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.HeartRateMinimum ())
            {
              const PatientData::HeartRateMinimum_type& x (*i.HeartRateMinimum ());
              if (typeid (PatientData::HeartRateMinimum_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "HeartRateMinimum",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "HeartRateMinimum",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ExpiratoryReserveVolume
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ExpiratoryReserveVolume ())
            {
              const PatientData::ExpiratoryReserveVolume_type& x (*i.ExpiratoryReserveVolume ());
              if (typeid (PatientData::ExpiratoryReserveVolume_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ExpiratoryReserveVolume",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ExpiratoryReserveVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // FunctionalResidualCapacity
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.FunctionalResidualCapacity ())
            {
              const PatientData::FunctionalResidualCapacity_type& x (*i.FunctionalResidualCapacity ());
              if (typeid (PatientData::FunctionalResidualCapacity_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "FunctionalResidualCapacity",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "FunctionalResidualCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // InspiratoryCapacity
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.InspiratoryCapacity ())
            {
              const PatientData::InspiratoryCapacity_type& x (*i.InspiratoryCapacity ());
              if (typeid (PatientData::InspiratoryCapacity_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "InspiratoryCapacity",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "InspiratoryCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // InspiratoryReserveVolume
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.InspiratoryReserveVolume ())
            {
              const PatientData::InspiratoryReserveVolume_type& x (*i.InspiratoryReserveVolume ());
              if (typeid (PatientData::InspiratoryReserveVolume_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "InspiratoryReserveVolume",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "InspiratoryReserveVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ResidualVolume
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.ResidualVolume ())
            {
              const PatientData::ResidualVolume_type& x (*i.ResidualVolume ());
              if (typeid (PatientData::ResidualVolume_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ResidualVolume",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "ResidualVolume",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // RespiratoryDriverAmplitudeBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.RespiratoryDriverAmplitudeBaseline ())
            {
              const PatientData::RespiratoryDriverAmplitudeBaseline_type& x (*i.RespiratoryDriverAmplitudeBaseline ());
              if (typeid (PatientData::RespiratoryDriverAmplitudeBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "RespiratoryDriverAmplitudeBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "RespiratoryDriverAmplitudeBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // TotalLungCapacity
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.TotalLungCapacity ())
            {
              const PatientData::TotalLungCapacity_type& x (*i.TotalLungCapacity ());
              if (typeid (PatientData::TotalLungCapacity_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "TotalLungCapacity",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "TotalLungCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // TotalVentilationBaseline
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.TotalVentilationBaseline ())
            {
              const PatientData::TotalVentilationBaseline_type& x (*i.TotalVentilationBaseline ());
              if (typeid (PatientData::TotalVentilationBaseline_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "TotalVentilationBaseline",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "TotalVentilationBaseline",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // VitalCapacity
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.VitalCapacity ())
            {
              const PatientData::VitalCapacity_type& x (*i.VitalCapacity ());
              if (typeid (PatientData::VitalCapacity_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "VitalCapacity",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "VitalCapacity",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, x);
            }
          }

          // ActiveEvent
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (PatientData::ActiveEvent_const_iterator
                 b (i.ActiveEvent ().begin ()), n (i.ActiveEvent ().end ());
                 b != n; ++b)
            {
              if (typeid (PatientData::ActiveEvent_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "ActiveEvent",
                    "uri:/mil/tatrc/physiology/datamodel",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "ActiveEvent",
                  "uri:/mil/tatrc/physiology/datamodel",
                  false, true, e, *b);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PatientData >
        _xsd_PatientData_type_serializer_init (
          "PatientData",
          "uri:/mil/tatrc/physiology/datamodel");


        void
        Patient (::std::ostream& o,
                 const ::mil::tatrc::physiology::datamodel::PatientData& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0);

          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::mil::tatrc::physiology::datamodel::Patient (s, m, f));

          ::xsd::cxx::tree::error_handler< char > h;

          ::xsd::cxx::xml::dom::ostream_format_target t (o);
          if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
          {
            h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
          }
        }

        void
        Patient (::std::ostream& o,
                 const ::mil::tatrc::physiology::datamodel::PatientData& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
        {
          ::xsd::cxx::xml::auto_initializer i (
            (f & ::xml_schema::flags::dont_initialize) == 0);

          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::mil::tatrc::physiology::datamodel::Patient (s, m, f));
          ::xsd::cxx::xml::dom::ostream_format_target t (o);
          if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
          {
            throw ::xsd::cxx::tree::serialization< char > ();
          }
        }

        void
        Patient (::std::ostream& o,
                 const ::mil::tatrc::physiology::datamodel::PatientData& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::mil::tatrc::physiology::datamodel::Patient (s, m, f));
          ::xsd::cxx::xml::dom::ostream_format_target t (o);
          if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
          {
            throw ::xsd::cxx::tree::serialization< char > ();
          }
        }

        void
        Patient (::xercesc::XMLFormatTarget& t,
                 const ::mil::tatrc::physiology::datamodel::PatientData& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::mil::tatrc::physiology::datamodel::Patient (s, m, f));

          ::xsd::cxx::tree::error_handler< char > h;

          if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
          {
            h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
          }
        }

        void
        Patient (::xercesc::XMLFormatTarget& t,
                 const ::mil::tatrc::physiology::datamodel::PatientData& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::mil::tatrc::physiology::datamodel::Patient (s, m, f));
          if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
          {
            throw ::xsd::cxx::tree::serialization< char > ();
          }
        }

        void
        Patient (::xercesc::XMLFormatTarget& t,
                 const ::mil::tatrc::physiology::datamodel::PatientData& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            ::mil::tatrc::physiology::datamodel::Patient (s, m, f));
          if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
          {
            throw ::xsd::cxx::tree::serialization< char > ();
          }
        }

        void
        Patient (::xercesc::DOMDocument& d,
                 const ::mil::tatrc::physiology::datamodel::PatientData& s,
                 ::xml_schema::flags)
        {
          ::xercesc::DOMElement& e (*d.getDocumentElement ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (e));

          if (typeid (::mil::tatrc::physiology::datamodel::PatientData) == typeid (s))
          {
            if (n.name () == "Patient" &&
                n.namespace_ () == "uri:/mil/tatrc/physiology/datamodel")
            {
              e << s;
            }
            else
            {
              throw ::xsd::cxx::tree::unexpected_element < char > (
                n.name (),
                n.namespace_ (),
                "Patient",
                "uri:/mil/tatrc/physiology/datamodel");
            }
          }
          else
          {
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
              "Patient",
              "uri:/mil/tatrc/physiology/datamodel",
              e, n, s);
          }
        }

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
        Patient (const ::mil::tatrc::physiology::datamodel::PatientData& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

          if (typeid (::mil::tatrc::physiology::datamodel::PatientData) == typeid (s))
          {
            d = ::xsd::cxx::xml::dom::serialize< char > (
              "Patient",
              "uri:/mil/tatrc/physiology/datamodel",
              m, f);
          }
          else
          {
            d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
              "Patient",
              "uri:/mil/tatrc/physiology/datamodel",
              m, s, f);
          }

          ::mil::tatrc::physiology::datamodel::Patient (*d, s, f);
          return d;
        }
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

